<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://https://luxin-oi.github.io/</id>
    <title>luxin</title>
    <updated>2020-03-04T17:16:21.046Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://https://luxin-oi.github.io/"/>
    <link rel="self" href="https://https://luxin-oi.github.io/atom.xml"/>
    <subtitle>♥Andromeda♥</subtitle>
    <logo>https://https://luxin-oi.github.io/images/avatar.png</logo>
    <icon>https://https://luxin-oi.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, luxin</rights>
    <entry>
        <title type="html"><![CDATA[图论总结（伪）]]></title>
        <id>https://https://luxin-oi.github.io/post/tu-lun-zong-jie-wei/</id>
        <link href="https://https://luxin-oi.github.io/post/tu-lun-zong-jie-wei/">
        </link>
        <updated>2020-03-04T17:13:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="图论总结">图论总结</h2>
<h3 id="dfs">DFS</h3>
<h4 id="套路1">套路1：</h4>
<p>​	构造的时候选一颗DFS树忽略其他边进行构造，</p>
<p>​	（对于点标和度数奇偶性的问题，假如所有的点的度数和为偶数的话，则成立）</p>
<h4 id="套路2">套路2：</h4>
<p>​	对于一个无向图求出一棵DFS树，然后每条非树边对应了一个环（每条非树边必然连向祖先）</p>
<p>​	例题：$$Xor$$和仙人掌判定(改点到祖先在树的路径)。</p>
<pre><code class="language-cpp">//dfs树+树形DP
#include&lt;iostream&gt; 
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ll long long
#define N 500010
#define M 1000010
#define P 998244353
char getc(){char c=getchar();while ((c&lt;'A'||c&gt;'Z')&amp;&amp;(c&lt;'a'||c&gt;'z')&amp;&amp;(c&lt;'0'||c&gt;'9')) c=getchar();return c;}
int gcd(int n,int m){return m==0?n:gcd(m,n%m);}
int read()
{
    int x=0,f=1;char c=getchar();
    while (c&lt;'0'||c&gt;'9') {if (c=='-') f=-1;c=getchar();}
    while (c&gt;='0'&amp;&amp;c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar();
    return x*f;
}
int T,n,m,p[N],f[N],size[N],fac[N],inv[N],inv2[N],fa[N],from[N],deep[N],t;
bool flag[N];
struct data{int to,nxt,op;
}edge[M&lt;&lt;1];
void addedge(int x,int y){t++;edge[t].to=y,edge[t].nxt=p[x],edge[t].op=0,p[x]=t;}
void inc(int &amp;x,int y){x+=y;if (x&gt;=P) x-=P;}
int C(int n,int m){return 1ll*fac[n]*inv[m]%P*inv[n-m]%P;}
int calc(int n,int m){return 1ll*C(n,2*m)*C(2*m,m)%P*fac[m]%P*inv2[m]%P;}
void dfs(int k)
{
    flag[k]=1;
    for (int i=p[k];i;i=edge[i].nxt) 
    if (!flag[edge[i].to]&amp;&amp;!edge[i].op)
    {
        size[k]++;
        dfs(edge[i].to);
        int s=0;
        for (int j=0;j&lt;=(size[edge[i].to]&gt;&gt;1);j++)
        inc(s,1ll*calc(size[edge[i].to],j)*(size[edge[i].to]-(j&lt;&lt;1)+1)%P);
        f[k]=1ll*f[k]*s%P*f[edge[i].to]%P;
    }
}
bool check(int i){edge[i].op++;if (i&amp;1) edge[i+1].op++;else edge[i-1].op++;return edge[i].op&lt;=1;}
bool maketag(int x,int y,int i)
{
    if (!check(i)) return 0;
    while (x!=y) {if (!check(from[x])) return 0;x=fa[x];}
    return 1;
}
bool iscactus(int k)
{
    flag[k]=1;
    for (int i=p[k];i;i=edge[i].nxt)
    if (edge[i].to!=fa[k])
        if (flag[edge[i].to]) {if (deep[edge[i].to]&lt;deep[k]&amp;&amp;!maketag(k,edge[i].to,i)) return 0;}
        else
        {
            fa[edge[i].to]=k;
            deep[edge[i].to]=deep[k]+1;
            from[edge[i].to]=i;
            if (!iscactus(edge[i].to)) return 0;
        }
    return 1;
}
int main()
{
#ifndef ONLINE_JUDGE
    freopen(&quot;bzoj4784.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;bzoj4784.out&quot;,&quot;w&quot;,stdout);
    const char LL[]=&quot;%I64d\n&quot;;
#else
    const char LL[]=&quot;%lld\n&quot;;
#endif
    T=read();
    while (T--)
    {
        n=read(),m=read();
        t=0;for (int i=1;i&lt;=n;i++) p[i]=0,size[i]=0,f[i]=1,flag[i]=0,deep[i]=0;
        fac[0]=1;for (int i=1;i&lt;=n;i++) fac[i]=1ll*fac[i-1]*i%P;
        inv[0]=inv[1]=1;for (int i=2;i&lt;=n;i++) inv[i]=P-1ll*(P/i)*inv[P%i]%P;
        inv2[0]=1;for (int i=1;i&lt;=n;i++) inv2[i]=1ll*inv2[i-1]*inv[2]%P;
        for (int i=2;i&lt;=n;i++) inv[i]=1ll*inv[i]*inv[i-1]%P;
        for (int i=1;i&lt;=m;i++)
        {
            int x=read(),y=read();
            addedge(x,y),addedge(y,x);
        }
        if (!iscactus(1)) {printf(&quot;0\n&quot;);continue;}
        for (int i=1;i&lt;=n;i++) flag[i]=0;
        int ans=1;
        for (int k=1;k&lt;=n;k++)
        if (!flag[k])
        {
            dfs(k);
            int s=0;
            for (int i=0;i&lt;=size[k]/2;i++) inc(s,calc(size[k],i));
            ans=1ll*ans*s%P*f[k]%P;
        }
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>
<h3 id="bfs">BFS</h3>
<p>在BFS图（无向图）中 。边只可能在相邻的两层或同一层之间连（BFS最优解的特性），并且每个点至少和上一层的一个点相连(<s>按照距离分层</s>)</p>
<h3 id="强连通双连通分量tarjan">强连通/双连通分量（$$Tarjan$$）</h3>
<h4 id="远古套路0">远古套路0：</h4>
<p>强连通缩点，在DAG上DP</p>
<pre><code class="language-cpp">//缩点
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
using namespace std;
struct Edge
{
	int from;
	int to;
	int next;
}e[200005],E[200005];
int n,m,edgenum,head[10005],w[10005],W[10005],low[10005],dfn[10005],where[10005];
int scc,stack[10005],f[10005],in[10005],top,ans;
queue&lt;int&gt;q;
vector&lt;int&gt;SCC[10005];
bool flag[10005];
void add(int u,int v)
{
	e[++edgenum].to=v;
	e[edgenum].from=u;
	e[edgenum].next=head[u];
	head[u]=edgenum;
}
int ind=0;
void Tarjan(int node,int fa)
{
	if(dfn[node])return;
	dfn[node]=++ind;
	low[node]=dfn[node];
	stack[++top]=node;
	flag[node]=1;
	for(int hd=head[node];hd;hd=e[hd].next)
	{
		if(!dfn[e[hd].to])
		{
			Tarjan(e[hd].to,node);
			low[node]=min(low[node],low[e[hd].to]);
		}
		else if(flag[e[hd].to])
		{
			low[node]=min(low[node],dfn[e[hd].to]);
		}
	}
	if(low[node]==dfn[node])
	{
		int v=stack[top--];
		SCC[++scc].push_back(v);
		where[v]=scc;
		flag[v]=0;
		W[scc]+=w[v];
		while(v!=node)
		{
			v=stack[top--];
			SCC[scc].push_back(v);
			where[v]=scc;
			flag[v]=0;
			W[scc]+=w[v];
		}
	}
}
void add2(int hd)
{
	E[++edgenum].from=where[e[hd].from];
	E[edgenum].to=where[e[hd].to];
	E[edgenum].next=head[E[edgenum].from];
	head[E[edgenum].from]=edgenum;
	in[E[edgenum].to]++;
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)
	  scanf(&quot;%d&quot;,&amp;w[i]);
	for(int i=1;i&lt;=m;i++)
	{
		int u,v;
		scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
		add(u,v);
	}
	for(int i=1;i&lt;=n;i++)
	  Tarjan(i,-1);
	edgenum=0;
	memset(head,0,sizeof(head));
	for(int i=1;i&lt;=m;i++)
	{
		if(where[e[i].from]!=where[e[i].to])
		  add2(i);
	}
	for(int i=1;i&lt;=scc;i++)
	  if(in[i]==0)
	  {
	    q.push(i);
	    f[i]=W[i];
	    ans=max(ans,f[i]);
	  }
	while(!q.empty())
	{
		int node=q.front();
		q.pop();
		ans=max(ans,f[node]);
		for(int hd=head[node];hd;hd=E[hd].next)
		{
			f[E[hd].to]=max(f[E[hd].to],f[node]+W[E[hd].to]);
			in[E[hd].to]--;
			if(in[E[hd].to]==0)
			{
				q.push(E[hd].to);
			}
		}
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}

</code></pre>
<h4 id="套路1-2">套路1：</h4>
<p>边（点）双联通分量缩起来形成一棵树，然后在树上搞事情。（比如加最少边让这个图变成双连通）</p>
<p><s>若一个无向连通图不存在割点，则称它为“点双连通图”。若一个无向连通图不存在割边，则称它为“边双连通图”。<br>
无向图的极大点双连通子图称为“点双连通分量”，简记为“v-DCC”。无向连通图的极大边双连通子图被称为“边双连通分量”，简记为“e-DCC”。二者统称为“双连通分量”，简记为“DCC”。</s></p>
<p><s>点双连通分量处理起来比较麻烦</s></p>
<p>例题：加最少边让图变成双连通（做法：先缩边双联通分量，然后答案就是$$ \lceil 叶子节点/2 \rceil $$</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#define lson x&lt;&lt;1
#define rson x&lt;&lt;1|1
#define ll long long
#define rint register int
#define mid ((st[x].l + st[x].r) &gt;&gt; 1)
using namespace std;
template &lt;typename xxx&gt; inline void read(xxx &amp;x) {
    char c = getchar(),f = 1;x = 0;
    for(;c ^ '-' &amp;&amp; !isdigit(c);c = getchar());
    if(c == '-') c = getchar(),f = -1;
    for(;isdigit(c);c = getchar()) x = (x&lt;&lt;1) + (x&lt;&lt;3) + (c ^ '0');
    x *= f;
}
template&lt;typename xxx&gt; inline void print(xxx x)
{
    if(x&lt;0){putchar('-');x=-x;}
    if(x&gt;9) print(x/10);
    putchar(x%10+'0');
}
const int maxn = 200010;
const int inf = 0x7fffffff;
const int mod = 1e9 + 7;
struct edge{
    int to,last,fg,from;    
}e[maxn];
int head[maxn],tot;
inline void add(int from,int to) {
    ++tot;
    e[tot].to = to;
    e[tot].from = from;
    e[tot].last = head[from];
    head[from] = tot;
}
int n,m;
int dfn[maxn],low[maxn],cnt;
inline void tarjan(int x,int in_edge) {
    dfn[x] = low[x] = ++cnt;
    for(rint i = head[x];i; i = e[i].last) {
        if(!dfn[e[i].to]) {
            tarjan(e[i].to,i);
            if(low[e[i].to] &lt; low[x]) low[x] = low[e[i].to];
            if(low[e[i].to] &gt; dfn[x]) {
                e[i].fg = e[i^1].fg = 1;
            }
        }
        else if(i ^ (in_edge ^ 1) &amp;&amp; dfn[e[i].to] &lt; low[x]) low[x] = dfn[e[i].to];
    }
}
int col[maxn],num,in[maxn];
inline void ddfs(int x) {
    col[x] = num;
    for(rint i = head[x];i;i = e[i].last) {
        if(col[e[i].to] || e[i].fg) continue;
        ddfs(e[i].to);
    }
}
int main()
{
    read(n);read(m);tot = 1;
    for(rint i = 1;i &lt;= m; ++i) {
        int x,y;
        read(x);read(y);
        add(x,y);add(y,x);
    }   
    for(rint i = 1;i &lt;= n; ++i) {
        if(!dfn[i]) {
            tarjan(i,0);
        }
    }
    for(rint i = 1;i &lt;= n; ++i) {
        if(!col[i]) {
            ++num;
            ddfs(i);
        }
    }
    for(rint i = 2;i &lt;= tot; ++i) {
        if(col[e[i].from] == col[e[i].to]) continue;
        ++in[col[e[i].from]];
        ++in[col[e[i].to]];
    }
    int ans = 0;
    for(rint i = 1;i &lt;= num; ++i) 
        if(in[i] == 2) ++ans;
    print((ans + 1) / 2);
    return 0;
}
</code></pre>
<h4 id="套路2-2">套路2：</h4>
<p>​	动态维护边双连通分量树</p>
<p>（<s>离线：先建树后处理。在线：$$lct$$/虚树</s>）</p>
<pre><code class="language-cpp">//BZOJ2959 长跑
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;bitset&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define pr pair&lt;int,int&gt;
#define ll long long
using namespace std;
int g[150010];
int fa[150010];
int f[150010];
int s[150010][2];
int v[150010];
int sum[150010];
int size[150010];
int st[150010];
int r[150010];
int n,m;
int opt;
int x,y;
int find(int x)
{
    if(fa[x]==x)
    {
        return x;
    }
    return fa[x]=find(fa[x]);
}
int judge(int x)
{
    if(g[x]==x)
    {
        return x;
    }
    return g[x]=judge(g[x]);
}
int is_root(int rt)
{
    return rt!=s[find(f[rt])][0]&amp;&amp;rt!=s[find(f[rt])][1];
}
int get(int rt)
{
    return rt==s[find(f[rt])][1];
}
void pushup(int rt)
{
    sum[rt]=sum[s[rt][0]]+sum[s[rt][1]]+size[rt];
}
void pushdown(int rt)
{
    if(r[rt])
    {
        swap(s[rt][0],s[rt][1]);
        r[s[rt][0]]^=1;
        r[s[rt][1]]^=1;
        r[rt]^=1;
    }
}
void rotate(int rt)
{
    int fa=find(f[rt]);
    int anc=find(f[fa]);
    int k=get(rt);
    if(!is_root(fa))
    {
        s[anc][get(fa)]=rt;
    }
    s[fa][k]=s[rt][k^1];
    f[s[fa][k]]=fa;
    s[rt][k^1]=fa;
    f[fa]=rt;
    f[rt]=anc;
    pushup(fa);
    pushup(rt);
}
void splay(int rt)
{
    int top=0;
    st[++top]=rt;
    for(int i=rt;!is_root(i);i=find(f[i]))
    {
        st[++top]=find(f[i]);
    }
    for(int i=top;i&gt;=1;i--)
    {
        pushdown(st[i]);
    }
    for(int fa;!is_root(rt);rotate(rt))
    {
        if(!is_root(fa=find(f[rt])))
        {
            rotate(get(fa)==get(rt)?fa:rt);
        }
    }
}
void access(int rt)
{
    for(int x=0;rt;x=rt,rt=find(f[rt]))
    {
        splay(rt);
        s[rt][1]=x;
        pushup(rt);
    }
}
void reverse(int rt)
{
    access(rt);
    splay(rt);
    r[rt]^=1;
}
void link(int x,int y)
{
    reverse(x);
    f[x]=y;
}
void dfs(int x,int rt)
{
    fa[x]=rt;
    if(s[x][0])
    {
        dfs(s[x][0],rt);
    }
    if(s[x][1])
    {
        dfs(s[x][1],rt);
    }
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++)
    {
        scanf(&quot;%d&quot;,&amp;v[i]);
        size[i]=v[i];
        sum[i]=v[i];
        fa[i]=i;
        g[i]=i;
    }
    while(m--)
    {
        scanf(&quot;%d%d%d&quot;,&amp;opt,&amp;x,&amp;y);
        int fx=find(x);
        int fy=find(y);
        if(opt==1)
        {  
            if(fx!=fy)
            {
                if(judge(fx)!=judge(fy))
                {
                    link(fx,fy);
                    g[g[fx]]=g[fy];
                }
                else
                {
                    reverse(fx);
                    access(fy);
                    splay(fy);
                    size[fy]=sum[fy];
                    dfs(fy,fy);
                    s[fy][0]=0;
                }
            }
        }
        else if(opt==2)
        {
            splay(fx);
            size[fx]+=y-v[x];
            sum[fx]+=y-v[x];
            v[x]=y;
        }
        else
        {
            if(judge(fx)!=judge(fy))
            {
                printf(&quot;-1\n&quot;);
            }
            else
            {
                reverse(fx);
                access(fy);
                splay(fy);
                printf(&quot;%d\n&quot;,sum[fy]);
            }
        }
    }
}
</code></pre>
<p>在OI比赛中结合数据结构考（图论模型一般比较明显）。</p>
<pre><code class="language-cpp">//强连通分量
#include&lt;queue&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 0x3f3f3f3f

vector&lt;int&gt; g[10010];
int color[10010],dfn[20020],low[20020],stack[20020],vis[10010],cnt[10010];
int deep,top,n,m,sum,ans;

void tarjan(int u)
{
    dfn[u]=++deep;
    low[u]=deep;
    vis[u]=1;
    stack[++top]=u;
    int sz=g[u].size();
    for(int i=0;i&lt;sz;i++)
    {
        int v=g[u][i];
        if(!dfn[v])
        {
            tarjan(v);
            low[u]=min(low[u],low[v]);
        }
        else
        {
            if(vis[v])
            {
                low[u]=min(low[u],low[v]);
            }
        }
    }
    if(dfn[u]==low[u])
    {
        color[u]=++sum;
        vis[u]=0;
        while(stack[top]!=u)
        {
            color[stack[top]]=sum;
            vis[stack[top--]]=0;
        }
        top--;
    }
}

int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=m;i++)
    {
        int from,to;
        scanf(&quot;%d%d&quot;,&amp;from,&amp;to);
        g[from].push_back(to);
    }
    for(int i=1;i&lt;=n;i++)
    {
        if(!dfn[i])
        {
            tarjan(i);
        }
    }
    for(int i=1;i&lt;=n;i++)
    {
        cnt[color[i]]++;
    }
    for(int i=1;i&lt;=sum;i++)
    {
        if(cnt[i]&gt;1)
        {
            ans++;
        }
    }
    printf(&quot;%d\n&quot;,ans);
}
</code></pre>
<pre><code class="language-cpp">//割点
#include&lt;cstdio&gt; 
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define hi printf(&quot;hi!&quot;);
using namespace std;

vector&lt;int&gt; g[10010];
int dfn[10010],low[10010],iscut[10010],son[10010];
int deep,root,n,m,ans;

int tarjan(int u,int fa)
{
    int child=0,lowu;
    lowu=dfn[u]=++deep;
    int sz=g[u].size();
    for(int i=0;i&lt;sz;i++)
    {
        int v=g[u][i];
        if(!dfn[v])
        {
            child++;
            int lowv=tarjan(v,u);
            lowu=min(lowu,lowv);
            if(lowv&gt;dfn[u])
            {
                iscut[u]=1;
            }
        }
        else
        {
            if(v!=fa&amp;&amp;dfn[v]&lt;dfn[u])
            {
                lowu=min(lowu,dfn[v]);
            }
        } 
    }
    if(fa&lt;0&amp;&amp;child==1)
    {
        iscut[u]=false;
    }
    low[u]=lowu;
    return lowu;
} 

int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=m;i++)
    {
        int from,to;
        scanf(&quot;%d%d&quot;,&amp;from,&amp;to);
        g[from].push_back(to);
        g[to].push_back(from);
    }
    for(int i=1;i&lt;=n;i++)
    {
        if(!dfn[i])
        {
            root=i;
            tarjan(i,-1);
        }
    }
    for(int i=1;i&lt;=n;i++)
    {
        if(iscut[i])
        {
            ans++;
        }
    }
    printf(&quot;%d\n&quot;,ans);
    for(int i=1;i&lt;=n;i++)
    {
        if(iscut[i])
        {
            printf(&quot;%d &quot;,i);
        }
    }
}
</code></pre>
<pre><code class="language-cpp">//割边/桥
#include&lt;cstdio&gt; 
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define hi printf(&quot;hi!&quot;);
using namespace std;

vector&lt;pair&lt;int,int&gt; &gt;bridge;
vector&lt;int&gt; g[10010];
int dfn[10010],low[10010];
int deep,root,n,m,ans;

int tarjan(int u,int fa)
{
    int lowu;
    lowu=dfn[u]=++deep;
    int sz=g[u].size();
    for(int i=0;i&lt;sz;i++)
    {
        int v=g[u][i];
        if(!dfn[v])
        {
            int lowv=tarjan(v,u);
            lowu=min(lowu,lowv);
            if(lowv&gt;dfn[u])
            {
                int from,to;
                from=u;
                to=v;
                if(from&gt;to)
                {
                    swap(from,to);
                }
                bridge.push_back(make_pair(from,to));
            }
        }
        else
        {
            if(v!=fa&amp;&amp;dfn[v]&lt;dfn[u])
            {
                lowu=min(lowu,dfn[v]);
            }
        } 
    }
    low[u]=lowu;
    return lowu;
} 

int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=m;i++)
    {
        int from,to;
        scanf(&quot;%d%d&quot;,&amp;from,&amp;to);
        g[from].push_back(to);
        g[to].push_back(from);
    }
    for(int i=1;i&lt;=n;i++)
    {
        if(!dfn[i])
        {
            root=i;
            tarjan(i,-1);
        }
    }
    for(int i=0;i&lt;bridge.size();i++)
    {
        printf(&quot;%d %d\n&quot;,bridge[i].first,bridge[i].second);
    }
}
</code></pre>
<h3 id="欧拉回路它很妙">欧拉回路（<s>它很妙</s>）</h3>
<p>需要掌握正确的有/无向图的欧拉回路/路径的求法</p>
<pre><code class="language-cpp">#include &quot;bits/stdc++.h&quot;

using namespace std;
const int maxn = 1e3;
int vis[maxn][maxn];
int n, m, x, y;
vector&lt;int&gt; e[maxn];
deque&lt;int&gt; q;

void addEdge(int a, int b) {
    e[a].push_back(b);
    e[b].push_back(a);
}

bool dfs(int now, int sum) {
    if (sum == m) {
        while (!q.empty()) {
            cout &lt;&lt; q.back() &lt;&lt; &quot; &quot;;
            q.pop_back();
        }
        cout &lt;&lt; endl;
        return 1;
    }
    for (int i = 0; i &lt; e[now].size(); i++) {
        if (!vis[now][e[now][i]]) {
            vis[now][e[now][i]] = 1;
            vis[e[now][i]][now] = 1;
            q.push_front(e[now][i]);
            if (dfs(e[now][i], sum + 1))
                return 1;
            q.pop_front();
            vis[now][e[now][i]] = 0;
            vis[e[now][i]][now] = 0;
        }
    }
    return 0;
}

int main() {、
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 0; i &lt; m; i++) {
        cin &gt;&gt; x &gt;&gt; y;
        addEdge(x, y);
    }
    q.push_front(1);
    if (!dfs(1, 0))
        cout &lt;&lt; &quot;NO answer&quot; &lt;&lt; endl;
    return 0;
}
</code></pre>
<h4 id="套路1-3">套路1：</h4>
<p>构造（构造一个序列或者能得一个无向图定向使得入度和出度差不超过1）</p>
<p>平面上有n个点$$(x,y)$$，将这些点红蓝染色实点每行每列的红蓝点个数的差不超过1（解法x,y建边，然后定向，染色<s>真TM奇特</s>）。</p>
<p>生成$$2^n$$ 的01串（串首尾相连），使得所有长度为n的01串都出现过</p>
<h4 id="套路2-3">套路2：</h4>
<p>根据充要条件处理度数（有向图联通其入度=出度；无向图只要联通且度数是偶数）</p>
<p>无向图加最少的边使得整个图成为欧拉图（做法为原理）。</p>
<p>混合图欧拉回路（无向图定向，性质）</p>
<pre><code class="language-cpp">//POJ 1637 
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
using namespace std;
const int MAXN = 1010;
const int MAXM = 50010;
const int INF = 0x3f3f3f3f;
struct Edge
{
	int v, f;
	int next;
}edge[MAXM];
int n, m;
int cnt;
int s, t;
int first[MAXN], level[MAXN];
int q[MAXN];
int ind[MAXN], outd[MAXN];
int totFlow;
void init()
{
	cnt = 0;
	totFlow = 0;
	memset(first, -1, sizeof(first));
	memset(ind, 0, sizeof(ind));
	memset(outd, 0, sizeof(outd));
}
void read(int u, int v, int f)
{
	edge[cnt].v = v, edge[cnt].f = f;
	edge[cnt].next = first[u], first[u] = cnt++;
}
void read_graph(int u, int v, int f)
{
	read(u, v, f);
	read(v, u, 0);
}
int bfs(int s, int t)
{
	memset(level, 0, sizeof(level));
	level[s] = 1;
	int front = 0, rear = 1;
	q[front] = s;
	while(front &lt; rear)
	{
		int x = q[front++];
		if(x == t) return 1;
		for(int e  = first[x]; e != -1; e = edge[e].next)
		{
			int v = edge[e].v, f = edge[e].f;
			if(!level[v] &amp;&amp; f)
			{
				level[v] = level[x] + 1;
				q[rear++] = v;
			}
		}
	}
	return 0;
}
int dfs(int u, int maxf, int t)
{
	if(u == t) return maxf;
	int ret = 0;
	for(int e = first[u]; e != -1; e = edge[e].next)
	{
		int v = edge[e].v, f = edge[e].f;
		if(level[v] == level[u] + 1 &amp;&amp; f)
		{
			int Min = min(maxf-ret, f);
			f = dfs(v, Min, t);
			edge[e].f -= f;
			edge[e^1].f += f;
			ret += f;
			if(ret == maxf) return ret;
		}
	}
	return ret;
}
int Dinic(int s, int t)
{
	int ans = 0;
	while(bfs(s, t)) ans += dfs(s, INF, t);
	return ans;
}
void read_case()
{
	init();
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	while(m--)
	{
		int u, v, flag;
		scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;flag);
		outd[u]++, ind[v]++;
		if(u != v)
		{
			if(!flag) read_graph(u, v, 1);
		}
	}
}
int build()
{
	int flag = 1;
	s = 0, t = n+1;
	for(int i = 1; i &lt;= n; i++)
	{
		if((ind[i]+outd[i]) &amp; 1) //出度加入度是奇数 
		{
			return 0;
		}
		else if(outd[i] &gt; ind[i]) //出度大于入度 
		{
			int dif = outd[i]-ind[i];
			read_graph(s, i, dif/2);
			totFlow += dif/2;
			
		} //可能有入度等于出度的情况,连不连无所谓 
		else
		{
			int dif = ind[i]-outd[i];
			read_graph(i, t, dif/2);
		}
	}
	return 1;
}
void solve()
{
	read_case();
	int flag = build();
	int ans = Dinic(s, t);
	if(!flag) printf(&quot;impossible\n&quot;);
	else if(ans &gt;= totFlow) printf(&quot;possible\n&quot;);
	else printf(&quot;impossible\n&quot;); 
}
int main()
{
	int T;
	scanf(&quot;%d&quot;, &amp;T);
	while(T--)
	{
		solve();
	}
	return 0;
}
</code></pre>
<h3 id="2-sat">2-SAT</h3>
<p>（<s>掌握做法和输出方案</s>）</p>
<pre><code class="language-cpp">//2-sat
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
using namespace std;
struct Edge
{
	int from;
	int to;
	int next;
}e[4000005];
int n,m,edgenum,head[2000005],p[2000005];
int dfn[2000005],low[2000005],st[2000005],scc,top;
bool flag[2000005];
queue&lt;int&gt;q;
void add(int u,int v)
{
	e[++edgenum].from=u;
	e[edgenum].to=v;
	e[edgenum].next=head[u];
	head[u]=edgenum;
}
int ind;
void Tarjan(int node)
{
	st[++top]=node;
	dfn[node]=low[node]=++ind;
	flag[node]=1;
	for(int hd=head[node];hd;hd=e[hd].next)
	{
		int to=e[hd].to;
		if(!dfn[to])
		{
			Tarjan(to);
			low[node]=min(low[node],low[to]);
		}
		else if(flag[to])low[node]=min(low[node],dfn[to]);
	}
	if(low[node]==dfn[node])
	{
		int v=st[top--];
		scc++;
		flag[v]=0;
		p[v]=scc;
		while(v!=node)
		{
			v=st[top--];
			flag[v]=0;
			p[v]=scc;
		}
	}
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=m;i++)
	{
		int x1,v1,x2,v2;
		scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;v1,&amp;x2,&amp;v2);
		add(x1+(!v1)*n,x2+v2*n);
		add(x2+(!v2)*n,x1+v1*n);
	}
	for(int i=1;i&lt;=2*n;i++)
	  if(!dfn[i])Tarjan(i);
	for(int i=1;i&lt;=n;i++)
	{
		if(p[i]==p[n+i])
		{
			printf(&quot;IMPOSSIBLE\n&quot;);
			return 0;
		}
	}
	printf(&quot;POSSIBLE\n&quot;);
	int num=edgenum;
	edgenum=0;
	memset(head,0,sizeof(head));
	memset(low,0,sizeof(low));
	for(int i=1;i&lt;=edgenum;i++)
	{
		int u=e[i].from,v=e[i].to;
		if(p[u]!=p[v])
		{
			add(p[u],p[v]);
			low[p[v]]++;
		}
	}
	ind=0;
	for(int i=1;i&lt;=scc;i++)
	  if(low[i]==0)
		q.push(i);
	while(!q.empty())
	{
		int node=q.front();
		q.pop();
		dfn[node]=++ind;
		for(int hd=head[node];hd;hd=e[hd].next)
		{
			int to=e[hd].to;
			low[to]--;
			if(low[to]==0)q.push(to);
		}
	}
	for(int i=1;i&lt;=n;i++)
	{
		if(dfn[p[i]]&gt;dfn[p[i+n]])putchar('1');
		else putchar('0');
		putchar(' ');
	}
	putchar('\n');
	return 0;
}

</code></pre>
<h4 id="套路-1">套路 1：</h4>
<p>建立辅助变量优化建图</p>
<p>会结合一些数据结构的常见手段（线段树 ST表 前缀 后缀）</p>
<p>比如一些变量至多只有一个可以为1的建图方法（<s>不会</s>）</p>
<h4 id="套路2-4">套路2：</h4>
<p>对于变量取值，拆除一堆$$x\leqslant1,x\leqslant2,x\leqslant3,……, $$这样的变量记作$$p_1,p_2,p_3,……$$</p>
<p>然后连$$p_2 \to p_1,p_1^, \to p_2^,,……  $$这样保证前面的取的是1，后面的取的是0</p>
<p>然后再根据不等式之类的限制连边。</p>
<h4 id="套路3">套路3：</h4>
<p>额外加一个限制，判断可不可行之类的。</p>
<p>相当于在这个图中加了两条边，判断$$x与x^,$$可不可达，转化到可达性问题。</p>
<h3 id="dominator-tree支配树">Dominator Tree（支配树）</h3>
<p><s>会吗并不会，考吗并不考。</s></p>
<p><a href="https://www.cnblogs.com/fenghaoran/p/dominator_tree.html">支配树(dominator tree) 学习笔记</a></p>
<p><a href="https://www.luogu.org/blog/214gtx/zhi-pei-shu-yang-xie">支配树详解</a></p>
<pre><code class="language-cpp">//luogu-P5180
# include &lt;iostream&gt;
# include &lt;cstdio&gt;
# include &lt;cstring&gt;
# include &lt;queue&gt;
# define sz 20
# define FOR(i,st,ed) for(int i=st;i&lt;=ed;++i)
# define _FOR(tu,u) for(int v,i=tu.hd[u];i;i=tu.e[i].nt)
# define _(tu) v=tu.e[i].to;
using namespace std;
int re(){
    int s=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch)){s=(s&lt;&lt;1)+(s&lt;&lt;3)+ch-'0';ch=getchar();}
    return s*f;
}//快读就不解释了

const int N=2e5+7;
struct MAP{
    struct edge{
        int to,nt;
    }e[N&lt;&lt;1];int cnt,hd[N];
    void link(int x,int y){e[++cnt]=(edge){y,hd[x]};hd[x]=cnt;}
}xx,a,ra,t,rt,z;//排除xx，依次表示原图，原图的反图，dfs树
//dfs树的反图，和最后的支配树
int n,m;

int dfn[N],dji,id[N],ff[N];//ff表示dfs树上的父节点
void dfs(int u){
    id[dfn[u]=++dji]=u;
    _FOR(a,u){
        _(a);
        if(!dfn[v]) dfs(v),ff[v]=u,t.link(u,v); 
    }
}//扣出一个dfs树

int anc[N],semi[N],mn[N];//这个mn[v],表示v点的dfs树上的祖先
//的semi最小的那个祖先，所以semi[mn[x]]=semi[x];
void init(){
    FOR(i,1,n) anc[i]=semi[i]=mn[i]=i;
}
int find(int u){
    if(u!=anc[u]){
        int t=anc[u];anc[u]=find(anc[u]);
        if(dfn[semi[mn[u]]]&gt;dfn[semi[mn[t]]]) mn[u]=mn[t];
    }
    return anc[u];
}//以上是带权并查集(路径压缩)
void len_tarjan(){
    init();
    for(int j=n;j&gt;=2;--j){
        int u=id[j],res=j;
        if(!u) continue;
        _FOR(ra,u){
            _(ra);
            if(!dfn[v]) continue;
            if(dfn[v]&lt;dfn[u]) res=min(res,dfn[v]);
            else find(v),res=min(res,dfn[semi[mn[v]]]);
        }
        semi[u]=id[res];anc[u]=ff[u];t.link(semi[u],u); 
    }
}//我们的tarjan大佬的算法

int ru[N],dep[N],fa[N][25];
int lca(int x,int y){
    if(dep[x]&lt;dep[y]) swap(x,y);
    int del=dep[x]-dep[y];
    FOR(i,0,sz)
        if((1&lt;&lt;i)&amp;del) x=fa[x][i];
    if(x==y) return x;
    for(int i=sz;i&gt;=0;--i)
        if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
    return fa[x][0];
}/lca
void work(int u){
    int t=rt.e[rt.hd[u]].to;
    _FOR(rt,u){
        _(rt);t=lca(t,v);
    }
    dep[u]=dep[t]+1;
    fa[u][0]=t;
    z.link(t,u);
    FOR(i,1,sz)
        fa[u][i]=fa[fa[u][i-1]][i-1]; 
}//建立支配树
void tpsort(){
    FOR(j,1,n)
        _FOR(t,j){
            _(t);
            ru[v]++;rt.link(v,j); 
        }   
    FOR(i,1,n) if(!ru[i]) t.link(0,i),rt.link(i,0);
    queue &lt;int&gt; q;q.push(0);
    while(q.size()){
        int u=q.front();q.pop();
        _FOR(t,u){
            _(t);
            if((--ru[v])&lt;=0) q.push(v),work(v);
        }
    } 
}

int siz[N];
void adfs(int u){
    siz[u]=1;
    _FOR(z,u){
        _(z);adfs(v);siz[u]+=siz[v];
    }
}//最后adfs用来搜答案
int main(){
    n=re();m=re();int x,y;
    FOR(i,1,m){
        x=re();y=re();
        a.link(x,y);ra.link(y,x);  
    }
    dfs(1);
    len_tarjan();
    tpsort();
    adfs(0);
    FOR(i,1,n) cout&lt;&lt;siz[i]&lt;&lt;' ';
    return 0;
}
</code></pre>
<h3 id="最短路">最短路</h3>
<h4 id="套路">套路：</h4>
<p>割点/边问最短路：</p>
<p>删边最短路一般来说都是考虑最短路径树，然后考虑每条非树边当成替换边之类的。</p>
<p>删点可以使用分治解决。</p>
<p>（$$dijkstra$$）边权小的话可以把堆换成桶解决。</p>
<p>变种:</p>
<p>比如边权，距离，价格有关之类的，可以用$$dijkstr$$每次确定最小值解决。</p>
<p>还有一些题的某些参数不知道，告诉你某些点之间的最短路的范围，然后求边权或者之类的</p>
<p>有些题目是可以通过一些精妙的分析解决。（一般可以写成线性规划，之间使用$$simplex$$  $$overkill$$一下就行了）</p>
<pre><code class="language-cpp">//dijkstra
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
using namespace std;
struct Edge
{
	int to;
	int nxt;
	int len;
}e[200005];
int n,m,s,edgenum,head[100005],dis[100005];
priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt; &gt;,greater&lt;pair&lt;int,int&gt; &gt; &gt;q;
void add(int u,int v,int l)
{
	e[++edgenum].len=l;
	e[edgenum].to=v;
	e[edgenum].nxt=head[u];
	head[u]=edgenum;
}
void Dijkstra()
{
	memset(dis,0x7f,sizeof(dis));
	dis[s]=0;
	q.push(make_pair(0,s));
	while(!q.empty())
	{
		int d=q.top().first;
		int node=q.top().second;
		q.pop();
		if(dis[node]!=d)continue;
		for(int hd=head[node];hd;hd=e[hd].nxt)
		{
			int to=e[hd].to;
			if(dis[to]&gt;dis[node]+e[hd].len)
			{
				dis[to]=dis[node]+e[hd].len;
				q.push(make_pair(dis[to],to));
			}
		}
	}
}
int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;s);
	for(int i=1;i&lt;=m;i++)
	{
		int u,v,l;
		scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;l);
		add(u,v,l);
	}
	Dijkstra();
	for(int i=1;i&lt;=n;i++)
	  printf(&quot;%d &quot;,dis[i]);
	printf(&quot;\n&quot;);
	return 0;
}

</code></pre>
<pre><code class="language-cpp">//SPFA
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
using namespace std;
struct Edge
{
	int to;
	int len;
	int next;
}e[100005];
int n,m,edgenum,head[10005],dis[10005],num[10005];
bool flag[10005];
queue&lt;int&gt;q;
void add(int u,int v,int l)
{
	e[++edgenum].len=l;
	e[edgenum].to=v;
	e[edgenum].next=head[u];
	head[u]=edgenum;
}
bool SPFA(int i)
{
	memset(dis,0x7f,sizeof(dis));
	dis[i]=0;
	q.push(i);
	flag[i]=1;
	while(!q.empty())
	{
		int node=q.front();
		q.pop();
		flag[node]=0;
		for(int hd=head[node];hd;hd=e[hd].next)
		{
			int to=e[hd].to;
			if(dis[to]&gt;dis[node]+e[hd].len)
			{
				dis[to]=dis[node]+e[hd].len;
				if(!flag[to])
				{
					q.push(to);
					flag[to]=1;
					num[to]++;
					if(num[to]&gt;m)return 0;
				}
			}
		}
	}
	return 1;
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=m;i++)
	{
		int u,v,l;
		scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;l);
		add(u,v,l);
	}
	if(!SPFA(1))
	{
		printf(&quot;No solution\n&quot;);
		return 0;
	}
	for(int i=1;i&lt;=n;i++)
	  printf(&quot;%d &quot;,dis[i]);
	printf(&quot;\n&quot;);
	return 0;
}

</code></pre>
<h3 id="k短路">K短路</h3>
<p>求k优解，或者之间问k短路。</p>
<p>做法：A*或者可并堆（<s>反正都不会</s>）。</p>
<pre><code class="language-cpp">//A*
#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef double db;
db dis[5005],f[5005];
int t[5005],vis[5005];
struct dat
{
    int u;
    db w;
    bool operator &lt; (const dat &amp;rhs) const {
        return w&gt;rhs.w;
    }
};
vector&lt;dat&gt; G[5005],g[5005];
void addedge(int i,int j,db w)
{
    G[i].push_back((dat){j,w});
    g[j].push_back((dat){i,w});
}
signed main()
{
    int n,m,ans=0;
    db e;
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;e;
    for (int i=1;i&lt;=m;i++)
    {
        int u,v;
        db w;
        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
        addedge(u,v,w);
    }
    memset(f,127,sizeof(f));
    f[n]=0;
    priority_queue&lt;dat&gt; q,Q;
    Q.push((dat){n,0});
    while (!Q.empty())
    {
        dat p=Q.top();Q.pop();
        int u=p.u;
        if (vis[u]) continue;
        vis[u]=1;
        for (int i=0;i&lt;g[u].size();i++)
        {
            dat v=g[u][i];
            if (f[u]+v.w&lt;f[v.u])
            {
                Q.push((dat){v.u,f[u]+v.w});
                f[v.u]=f[u]+v.w;
            }
        }
    }
    q.push((dat){1,f[1]});
    while (!q.empty())
    {
        dat p=q.top();q.pop();
        int u=p.u;
        db w=p.w-f[u];
        if (u==n)
        {
            e-=w;
            if (e&gt;=1e-6) ans++;
            else break;
            continue;
        }
        for (int i=0;i&lt;G[u].size();i++)
        {
            dat v=G[u][i];
            q.push((dat){v.u,w+v.w+f[v.u]});
        }
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
</code></pre>
<pre><code class="language-cpp">//可并堆
# include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
template &lt;class Num&gt; inline void Cmax(Num &amp;x, const Num y) {
    x = y &gt; x ? y : x;
}
template &lt;class Num&gt; inline void Cmin(Num &amp;x, const Num y) {
    x = y &lt; x ? y : x;
}
const int maxn(5005);
const int maxm(2e5 + 5);
const double eps(1e-8);
int n, m, first[maxn], cnt, vis[maxn], rt[maxn], tot, cov[maxm &lt;&lt; 1], ans, fa[maxn];
double se, e, dis[maxn];
priority_queue &lt; pair &lt;double, int&gt; &gt; q;
struct Heap {
    int ls, rs, dis, ed;
    double w;
} tr[maxm * 20];
struct Edge {
    int to, next;
    double w;
} edge[maxm &lt;&lt; 1];
inline void Add(int u, int v, double w) {
    edge[cnt] = (Edge){v, first[u], w}, first[u] = cnt++;
    edge[cnt] = (Edge){u, first[v], w}, first[v] = cnt++;
}
inline int NewNode(double w, int ed) {
    int x = ++tot;
    tr[x].w = w, tr[x].dis = 1, tr[x].ed = ed;
    return x;
}
int Merge(int x, int y) {
    if (!x || !y) return x + y;
    if (tr[x].w - tr[y].w &gt;= eps) swap(x, y);
    int p = ++tot;
    tr[p] = tr[x], tr[p].rs = Merge(tr[p].rs, y);
    if (tr[tr[p].ls].dis &lt; tr[tr[p].rs].dis) swap(tr[p].ls, tr[p].rs);
    tr[p].dis = tr[tr[x].rs].dis + 1;
    return p;
}
void Dfs(int u) {
    vis[u] = 1;
    for (int e = first[u], v; e != -1; e = edge[e].next)
        if (e &amp; 1) {
            double w = edge[e].w;
            if (fabs(dis[u] + w - dis[v = edge[e].to]) &lt; eps &amp;&amp; !vis[v])
                fa[v] = u, cov[e ^ 1] = 1, Dfs(v);
        }
}
int main() {
    memset(first, -1, sizeof(first));
    memset(dis, 127, sizeof(dis));
    scanf(&quot;%d%d%lf&quot;, &amp;n, &amp;m, &amp;se);
    for (int i = 1, u, v; i &lt;= m; ++i) scanf(&quot;%d%d%lf&quot;, &amp;u, &amp;v, &amp;e), Add(u, v, e);
    dis[n] = 0, q.push(make_pair(0, n));
    while (!q.empty()) {
        int u = q.top().second;
        q.pop();
        if (vis[u]) continue;
        vis[u] = 1;
        for (int e = first[u]; ~e; e = edge[e].next)
            if (e &amp; 1) {
                int v = edge[e].to;
                if (dis[v] - (dis[u] + edge[e].w) &gt;= eps)
                    q.push(make_pair(-(dis[v] = dis[u] + edge[e].w), v));
            }
    }
    for (int i = 1; i &lt;= n; ++i) vis[i] = 0;
    Dfs(n);
    for (int e = 0, u, v; e &lt; cnt; e += 2)
        if (!cov[e]) {
            u = edge[e ^ 1].to, v = edge[e].to;
            if (dis[u] == dis[0] || dis[v] == dis[0]) continue;
            rt[u] = Merge(rt[u], NewNode(dis[v] + edge[e].w - dis[u], v));
        }
    for (int i = 1; i &lt;= n; ++i) q.push(make_pair(-dis[i], i));
    for (int i = 1, u; i &lt;= n; ++i) {
        u = q.top().second, q.pop();
        if (fa[u]) rt[u] = Merge(rt[u], rt[fa[u]]);
    }
    if (dis[1] - se &lt; eps) se -= dis[1], ++ans;
    if (rt[1]) q.push(make_pair(-tr[rt[1]].w, rt[1]));
    while (!q.empty()) {
        int ed = q.top().second;
        double cur = q.top().first, w = dis[1] - cur;
        if (w - se &gt;= eps) break;
        q.pop(), se -= w, ++ans;
        for (int i = 0; i &lt; 2; ++i) {
            int nxt = i ? tr[ed].rs : tr[ed].ls;
            if (nxt) q.push(make_pair(cur + tr[ed].w - tr[nxt].w, nxt));
        }
        if (rt[tr[ed].ed]) q.push(make_pair(cur - tr[rt[tr[ed].ed]].w, rt[tr[ed].ed]));
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
</code></pre>
<h3 id="差分约束">差分约束</h3>
<p>对于$$s(v)\leqslant s(u)+w(u,v)$$的限制建图，然后求解。</p>
<p>一般就是根据题意把变量和限制写出来，如果每个限制都只和某两项的差有关，可以使用差分约束解决。</p>
<p>考虑前缀和也是常见手段。</p>
<pre><code class="language-cpp">//luogu-p1993
#include&lt;bits/stdc++.h&gt;
#define il inline
#define For(i,a,b) for(int (i)=(a);(i)&lt;=(b);(i)++)
using namespace std;
const int N=50005,inf=23333333;
int n,m,to[N],net[N],w[N],dis[N],cnt,h[N],tot[N];
bool vis[N];

il int gi(){
    int a=0;char x=getchar();
    while(x&lt;'0'||x&gt;'9')x=getchar();
    while(x&gt;='0'&amp;&amp;x&lt;='9')a=(a&lt;&lt;3)+(a&lt;&lt;1)+x-48,x=getchar();
    return a;
}

il void add(int u,int v,int c){to[++cnt]=v,net[cnt]=h[u],h[u]=cnt,w[cnt]=c;}

il bool spfa(int u){
    vis[u]=1;
    for(int i=h[u];i;i=net[i])
        if(dis[to[i]]&lt;dis[u]+w[i]){
            dis[to[i]]=dis[u]+w[i];
            if(vis[to[i]])return 0;
            if(!spfa(to[i]))return 0;
        }
    vis[u]=0;
    return 1;
}

int main(){
    n=gi(),m=gi();
    int f,a,b,c;
    while(m--){
        f=gi(),a=gi(),b=gi();
        if(f==1)c=gi(),add(b,a,c);
        else if(f==2)c=gi(),add(a,b,-c);
        else if(f==3)add(a,b,0),add(b,a,0);
    }
    For(i,1,n)add(0,i,0),dis[i]=-inf;
    if(!spfa(0))cout&lt;&lt;&quot;No&quot;;
    else cout&lt;&lt;&quot;Yes&quot;;
    return 0;
}
</code></pre>
<h3 id="网络流">网络流</h3>
<p>最好能掌握多种费用流算法（$$SPFA$$增广，$$dkw$$费用流），以及掌握有负环/上下界的费用流。最大流（$$dinic$$）；</p>
<pre><code class="language-cpp">//spfa增广
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=705,maxe=144005,INF=0x3f3f3f3f;
int N,M,S,T,n,tim[65][15],id[65][15],ans=0;
int tot=1,son[maxe],nxt[maxe],lnk[maxn],flw[maxe],cap[maxe],w[maxe];
void add(int x,int y,int z){
    son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;flw[tot]=0;cap[tot]=1;w[tot]=z;
    son[++tot]=x;nxt[tot]=lnk[y];lnk[y]=tot;flw[tot]=0;cap[tot]=0;w[tot]=-z;
}
#define nc getchar
inline int red(){
    int tot=0,f=1;char ch=nc();
    while (ch&lt;'0'||'9'&lt;ch) {if (ch=='-') f=-f;ch=nc();}
    while ('0'&lt;=ch&amp;&amp;ch&lt;='9') tot=tot*10+ch-48,ch=nc();
    return tot*f;
}
int que[maxn],dst[maxn],fa[maxn],ed[maxn];
bool vis[maxn];
bool spfa(){
    memset(dst,63,sizeof(dst));
    memset(vis,0,sizeof(vis));
    int hed=0,til=1;
    que[1]=S;dst[S]=0;fa[S]=0;
    while (hed!=til){
        int x=que[hed=(hed+1)%maxn];
        vis[x]=0;
        for (int j=lnk[x];j;j=nxt[j])
         if (cap[j]&gt;flw[j]&amp;&amp;dst[son[j]]&gt;dst[x]+w[j]){
            dst[son[j]]=dst[x]+w[j];
            fa[son[j]]=x;ed[son[j]]=j;
            if (!vis[son[j]])
             vis[son[j]]=1,
             que[til=(til+1)%maxn]=son[j];
         }
    }
    if (dst[T]==INF) return 0;
    return 1;
}
int main(){
    //do something...
    while (spfa()){
        int Min=INF;
        for (int j=T;j!=S;j=fa[j]) Min=min(Min,cap[ed[j]]-flw[ed[j]]);
        for (int j=T;j!=S;j=fa[j]) flw[ed[j]]+=Min,flw[ed[j]^1]-=Min;
        ans+=dst[T]*Min;
    }
    printf(&quot;%.2lf&quot;,(double)ans/N);
    return 0;
}
</code></pre>
<pre><code class="language-cpp">//dinic
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
using namespace std;
const int INF=2147483647;
struct Edge
{
	int from;
	int to;
	int next;
	int flow;
}e[200005];
int n,m,s,t,edgenum=1,dep[50005],head[50005];
queue&lt;int&gt;q;
void add(int u,int v,int f)
{
	e[++edgenum].flow=f;
	e[edgenum].from=u;
	e[edgenum].to=v;
	e[edgenum].next=head[u];
	head[u]=edgenum;
}
bool bfs()
{
	while(!q.empty())q.pop();
	memset(dep,0,sizeof(dep));
	dep[s]=1;
	q.push(s);
	while(!q.empty())
	{
		int node=q.front();
		q.pop();
		for(int hd=head[node];hd;hd=e[hd].next)
		{
			int to=e[hd].to;
			if(e[hd].flow&amp;&amp;dep[to]==0)
			{
				dep[to]=dep[node]+1;
				q.push(to);
			}
		}
	}
	return dep[t];
}
int dfs(int node,int nowf)
{
	if(node==t)return nowf;
	for(int hd=head[node];hd;hd=e[hd].next)
	{
		int to=e[hd].to;
		if(dep[to]==dep[node]+1&amp;&amp;e[hd].flow)
		{
			int d=dfs(to,min(nowf,e[hd].flow));
			if(d&gt;0)
			{
				e[hd].flow-=d;
				e[hd^1].flow+=d;
				return d;
			}
		}
	}
	return 0;
}
int Dinic()
{
	int ans=0,d;
	while(bfs())
	{
		while(d=dfs(s,INF))
		  ans+=d;
	}
	return ans;
}
int main()
{
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;s,&amp;t);
	for(int i=1;i&lt;=m;i++)
	{
		int u,v,f;
		scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;f);
		add(u,v,f);
		add(v,u,0);
	}
	printf(&quot;%d\n&quot;,Dinic());
	return 0;
}

</code></pre>
<h4 id="套路0">套路0：</h4>
<p>有负环/上下界的最大/最小/费用/循环流（无源点和汇点）。</p>
<h4 id="套路1-4">套路1：</h4>
<p>建立线性规划的式子然后对偶成为费用流。($$ simplex $$不会比对偶费用流慢多少，之间背有初始解的模板）</p>
<h4 id="套路2-5">套路2：</h4>
<p>建立一堆辅助变量变成等式，然后通过一些高明的技巧使得每个东西一正一反出现在这些等式里，然后根据流量平衡见图。</p>
<p>一般来说这些$$LP-based$$的网络流题都是费用流。因为最大流的对偶是最小割。处理的方法比较套路。而费用流的运行速度和$$simplex$$也差不了多少。无脑$$simplex$$。</p>
<pre><code class="language-cpp">//simplex
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;cstdio&gt;
#include&lt;ctime&gt;
#include&lt;cmath&gt;
#include&lt;map&gt;
#define Redge(u) for (int k = h[u],to; k; k = ed[k].nxt)
#define REP(i,n) for (int i = 1; i &lt;= (n); i++)
#define mp(a,b) make_pair&lt;int,int&gt;(a,b)
#define cls(s) memset(s,0,sizeof(s))
#define cp pair&lt;int,int&gt;
#define LL long long int
using namespace std;
const int maxn = 25,maxm = 100005;
const double eps = 1e-8,INF = 1e15;
inline int read(){
    int out = 0,flag = 1; char c = getchar();
    while (c &lt; 48 || c &gt; 57){if (c == '-') flag = -1; c = getchar();}
    while (c &gt;= 48 &amp;&amp; c &lt;= 57){out = (out &lt;&lt; 3) + (out &lt;&lt; 1) + c - 48; c = getchar();}
    return out * flag;
}
int n,m,id[maxn &lt;&lt; 1];
double a[maxn][maxn],ans[maxn];
void Pivot(int l,int e){
    swap(id[n + l],id[e]);
    double t = a[l][e]; a[l][e] = 1;
    for (int j = 0; j &lt;= n; j++) a[l][j] /= t;
    for (int i = 0; i &lt;= m; i++) if (i != l &amp;&amp; abs(a[i][e]) &gt; eps){
        t = a[i][e]; a[i][e] = 0;
        for (int j = 0; j &lt;= n; j++) a[i][j] -= a[l][j] * t;
    }
}
bool init(){
    while (true){
        int e = 0,l = 0;
        for (int i = 1; i &lt;= m; i++) if (a[i][0] &lt; -eps &amp;&amp; (!l|| (rand() &amp; 1))) l = i;
        if (!l) break;
        for (int j = 1; j &lt;= n; j++) if (a[l][j] &lt; -eps &amp;&amp; (!e || (rand() &amp; 1))) e = j;
        if (!e){puts(&quot;Infeasible&quot;); return false;}
        Pivot(l,e);
    }
    return true;
}
bool simplex(){
    while (true){
        int l = 0,e = 0; double mn = INF;
        for (int j = 1; j &lt;= n; j++) if (a[0][j] &gt; eps){e = j; break;}
        if (!e) break;
        for (int i = 1; i &lt;= m; i++) if (a[i][e] &gt; eps &amp;&amp; a[i][0] / a[i][e] &lt; mn)
            mn = a[i][0] / a[i][e],l = i;
        if (!l){puts(&quot;Unbounded&quot;); return false;}
        Pivot(l,e);
    }
    return true;
}
int main(){
    srand(time(NULL));
    n = read(); m = read(); int t = read();
    REP(i,n) a[0][i] = read();
    REP(i,m){
        REP(j,n) a[i][j] = read();
        a[i][0] = read();
    }
    REP(i,n) id[i] = i;
    if (init() &amp;&amp; simplex()){
        printf(&quot;%.8lf\n&quot;,-a[0][0]);
        if (t){
            REP(i,m) ans[id[n + i]] = a[i][0];
            REP(i,n) printf(&quot;%.8lf &quot;,ans[i]);
        }
    }
    return 0;
}
</code></pre>
<h3 id="最小生成树">最小生成树</h3>
<p>掌握$$Prim/Kruskal/Boruvka$$算法。</p>
<pre><code class="language-cpp">//Prim
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
using namespace std;
typedef long long ll;
const int maxn = 2e3 + 10;
const int INF = 1 &lt;&lt; 30;
int dir[4][2] = {1,0,0,1,-1,0,0,-1};
int T, n, m, x;
int Map[maxn][maxn];//存图
int lowcost[maxn], mst[maxn];
void prim(int u)//最小生成树起点
{
    int sum_mst = 0;//最小生成树权值
    for(int i = 1; i &lt;= n; i++)//初始化两个数组
    {
        lowcost[i] = Map[u][i];
        mst[i] = u;
    }
    mst[u] = -1;//设置成-1表示已经加入mst
    for(int i = 1; i &lt; n; i++)//此处只需要迭代n-1次即可
    {
        int minn = INF;
        int v = -1;
        //在lowcost数组中寻找未加入mst的最小值
        for(int j = 1; j &lt;= n; j++)
        {
            if(mst[j] != -1 &amp;&amp; lowcost[j] &lt; minn)
            {
                v = j;
                minn = lowcost[j];
            }
        }
        if(v != -1)//v=-1表示未找到最小的边,
        {//v表示当前距离mst最短的点
            printf(&quot;%d %d %d\n&quot;, mst[v], v, lowcost[v]);//输出路径
            mst[v] = -1;
            sum_mst += lowcost[v];
            for(int j = 1; j &lt;= n; j++)//更新最短边
            {
                if(mst[j] != -1 &amp;&amp; lowcost[j] &gt; Map[v][j])
                {
                    lowcost[j] = Map[v][j];
                    mst[j] = v;
                }
            }
        }
    }
    printf(&quot;weight of mst is %d\n&quot;, sum_mst);
}
int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    memset(Map, 0, sizeof(Map));
    for(int i = 1; i &lt;= m; i++)
    {
        int u, v, w;
        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        Map[u][v] = Map[v][u] = w;
    }
    for(int i = 1; i &lt;= n; i++)
    {
        for(int j = 1; j &lt;= n; j++)
        {
            if(i == j)Map[i][j] = 0;
            else if(!Map[i][j])Map[i][j] = INF;
        }
    }
    prim(1);
    return 0;
}
</code></pre>
<pre><code class="language-cpp">//kruskal
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,m,tot=0,k=0;//n端点总数，m边数，tot记录最终答案，k已经连接了多少边 
int fat[200010];//记录集体老大 
struct node
{
	int from,to,dis;//结构体储存边 
}edge[200010];
bool cmp(const node &amp;a,const node &amp;b)//sort排序（当然你也可以快排） 
{
	return a.dis&lt;b.dis;
}
int father(int x)//找集体老大，并查集的一部分 
{
	if(fat[x]!=x)
	return father(fat[x]);
	else return x;
}
void unionn(int x,int y)//加入团体，并查集的一部分 
{
	fat[father(y)]=father(x);
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);//输入点数，边数 
	for(int i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;edge[i].from,&amp;edge[i].to,&amp;edge[i].dis);//输入边的信息 
	}
	for(int i=1;i&lt;=n;i++) fat[i]=i;//自己最开始就是自己的老大 （初始化） 
	sort(edge+1,edge+1+m,cmp);//按权值排序（kruskal的体现） 
	for(int i=1;i&lt;=m;i++)//从小到大遍历 
	{
		if(k==n-1) break;//n个点需要n-1条边连接 
		if(father(edge[i].from)!=father(edge[i].to))//假如不在一个团体 
		{
			unionn(edge[i].from,edge[i].to);//加入 
			tot+=edge[i].dis;//记录边权 
			k++;//已连接边数+1 
		}
	}
	printf(&quot;%d&quot;,tot);
	return 0;
}
</code></pre>
<pre><code class="language-cpp">//broucvka解曼哈顿距离最大生成树
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;vector&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;ll,int&gt; abcd;
inline char nc(){
  static char buf[100000],*p1=buf,*p2=buf;
  return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline void read(int &amp;x){
  char c=nc(),b=1;
  for (;!(c&gt;='0' &amp;&amp; c&lt;='9');c=nc()) if (c=='-') b=-1;
  for (x=0;c&gt;='0' &amp;&amp; c&lt;='9';x=x*10+c-'0',c=nc()); x*=b;
}
const int N=100005;
const int dx[]={1,-1,1,-1};
const int dy[]={-1,-1,1,1};
set&lt;abcd&gt; Set[4];
int n; ll Ans=0;
int x[N],y[N];
ll a[N][4];
int fat[N];
#define pb push_back
vector&lt;int&gt; g[N];
inline int Fat(int u){
  return fat[u]==u?u:fat[u]=Fat(fat[u]);
}
inline bool Merge(int x,int y){
  x=Fat(x); y=Fat(y); if (x==y) return 0;
  for (int i=0;i&lt;(int)g[x].size();i++) g[y].pb(g[x][i]);
  g[x].clear();
  fat[x]=y; return 1; 
}
struct edge{
  int u,v,w;
  edge(int u=0,int v=0,int w=0):u(u),v(v),w(w) { }
}ed[N];
int pnt=0;
int main(){
  freopen(&quot;mst.in&quot;,&quot;r&quot;,stdin);
  freopen(&quot;mst.out&quot;,&quot;w&quot;,stdout);
  read(n);
  for (int i=1;i&lt;=n;i++){
    read(x[i]); read(y[i]);
    for (int j=0;j&lt;4;j++){
      a[i][j]=x[i]*dx[j]+y[i]*dy[j];
      Set[j].insert(abcd(a[i][j],i));
    }
  }
  for (int i=1;i&lt;=n;i++) fat[i]=i,g[i].pb(i);
  Ans=0;
  while (1){
    int flag=0; pnt=0;
    for (int i=1;i&lt;=n;i++){
      if (fat[i]!=i) continue;
      if (g[i].size()==n){
    flag=1; break;
      }
      for (int j=0;j&lt;(int)g[i].size();j++)
    for (int k=0;k&lt;4;k++)
      Set[k].erase(abcd(a[g[i][j]][k],g[i][j]));
      ll Max=-1LL&lt;&lt;40,v;
      for (int k=0;k&lt;4;k++){
    ll maxu=-1LL&lt;&lt;40,maxv;
    for (int j=0;j&lt;(int)g[i].size();j++)
      if (a[g[i][j]][k]&gt;=maxu)
        maxu=a[g[i][j]][k];
    set&lt;abcd&gt;::iterator it=Set[k^3].end(); it--;
    maxv=it-&gt;first;
    if (maxu+maxv&gt;=Max)
      Max=maxu+maxv,v=it-&gt;second;
      }
      ed[++pnt]=edge(i,v,Max);
      for (int j=0;j&lt;(int)g[i].size();j++)
    for (int k=0;k&lt;4;k++)
      Set[k].insert(abcd(a[g[i][j]][k],g[i][j]));
    }
    if (flag) break;
    for (int j=1;j&lt;=pnt;j++)
      if (Merge(ed[j].u,ed[j].v))
    Ans+=ed[j].w;
  }
  printf(&quot;%lld\n&quot;,Ans);
  return 0;
}

</code></pre>
<h4 id="套路1-5">套路1：</h4>
<p>两点之间路径的边/点权的最大值最小（最小值最大）。</p>
<h3 id="套路2-6">套路2：</h3>
<p>动态维护最小生成树（加边/删边）</p>
<p>动态图中可以把每条边的删除时间当成边权维护最大生成树。</p>
<pre><code class="language-cpp">//魔法森林
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
typedef long long ll;
const int MAXN = 50010;
const int MAXM = 100010;
const int MAXS = MAXN + MAXM;
const int INF = 1061109567;
inline int Max(const int a, const int b){ return (a &gt; b) ? a : b; }
inline int Min(const int a, const int b){ return (a &lt; b) ? a : b; }
inline int read(){
    int x = 0; int w = 1; register char c = getchar();
    for(; c ^ '-' &amp;&amp; (c &lt; '0' || c &gt; '9'); c = getchar());
    if(c == '-') w = -1, c = getchar();
    for(; c &gt;= '0' &amp;&amp; c &lt;= '9'; c = getchar()) x = (x&lt;&lt;3) + (x&lt;&lt;1) + c - '0'; return x * w;
}
struct Edge{
    int x,y,a,b;
}e[MAXM];
int N,M,ans(INF),maxa;
int val[MAXS],mx[MAXS];
struct LinkCutTree{
    int ch[MAXS][2],fa[MAXS];
    bool tag[MAXS];
    inline bool rson(int f, int x){
        return ch[f][1] == x;
    }
    inline bool isroot(int x){
        return ch[fa[x]][0]!=x &amp;&amp; ch[fa[x]][1]!=x;
    }
    inline void pushup(int x){
        mx[x] = x;
        if(val[mx[ch[x][0]]] &gt; val[mx[x]]) mx[x] = mx[ch[x][0]];
        if(val[mx[ch[x][1]]] &gt; val[mx[x]]) mx[x] = mx[ch[x][1]];
    }
    inline void rotate(int x){
        int f = fa[x], gf = fa[f];
        bool p = rson(f,x), q = !p;
        if(!isroot(f)) ch[gf][rson(gf,f)] = x; fa[x] = gf;
        ch[f][p] = ch[x][q], fa[ch[x][q]] = f;
        ch[x][q] = f, fa[f] = x;
        pushup(f), pushup(x);
    }
    void reverse(int x){
        if(!isroot(x)) reverse(fa[x]);
        if(!tag[x]) return;
        tag[x] = 0;
        swap(ch[x][0], ch[x][1]);
        tag[ch[x][0]] ^= 1, tag[ch[x][1]] ^= 1;
    }
    inline void splay(int x){
        for(reverse(x); !isroot(x); rotate(x)){
            if(isroot(fa[x])){ rotate(x); break; }
            if(rson(fa[fa[x]],fa[x]) ^ rson(fa[x],x)) rotate(x); else rotate(fa[x]);
        }
    }
    inline void access(int x){
        for(int y = 0; x; y=x, x = fa[x]) splay(x), ch[x][1] = y, pushup(x);
    }
    inline void mroot(int x){
        access(x), splay(x), tag[x] ^= 1;
    }
    inline int findroot(int x){
        access(x), splay(x);
        while(ch[x][0]) x = ch[x][0];
        return x;
    }
    inline void split(int x, int y){
        mroot(x);
        access(y);
        splay(y);
    }
    inline void link(int x, int y){
        mroot(x);
        fa[x] = y;
    }
    inline void cut(int x, int y){
        split(x,y);
        if(ch[y][0] != x || ch[x][1]) return;
        ch[y][0] = fa[x] = 0;
    }
}qxz;
inline bool cmp(const Edge&amp; a, const Edge&amp; b){
    return a.a &lt; b.a;
}
int main(){
//  freopen(&quot;.in&quot;,&quot;r&quot;,stdin);
    N = read(), M = read();
    for(int i = 1; i &lt;= M; ++i){
        e[i].x = read(), e[i].y = read(), e[i].a = read(), e[i].b = read();
    }
    sort(e+1, e+M+1, cmp);
    for(int i = 1; i &lt;= M; ++i){
        val[N+i] = e[i].b;
        if(qxz.findroot(e[i].x) != qxz.findroot(e[i].y)){
            qxz.link(e[i].x, N+i);
            qxz.link(e[i].y, N+i);
            maxa = e[i].a;
        }
        else{
            qxz.split(e[i].x, e[i].y);
            if(val[mx[e[i].y]] &gt; e[i].b){
                int temp = mx[e[i].y]-N;
                qxz.cut(e[temp].x, temp+N);
                qxz.cut(e[temp].y, temp+N);
                qxz.link(e[i].x, N+i);
                qxz.link(e[i].y, N+i);
                maxa = e[i].a;
            }
        }
        if(qxz.findroot(1) == qxz.findroot(N)){
            qxz.split(1, N);
            ans = Min(ans, maxa + val[mx[N]]);
        }
    }
    if(ans == INF) printf(&quot;-1&quot;);
    else printf(&quot;%d&quot;, ans);
    return 0;
}
</code></pre>
<h4 id="套路3-2">套路3：</h4>
<p>完全图，每条边的边权为$$w(u)$$ $$op$$ $$w(v)$$。</p>
<p>一般来说可以用$$prim或者Boruvka$$。</p>
<h3 id="最小树形图">最小树形图</h3>
<p>掌握朱刘算法及输出方案。</p>
<pre><code class="language-cpp">//hdu 2121 Ice_cream’s world II
#include&lt;iostream&gt;
using namespace std;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define MAXN 1005
#define INF 0x7f7f7f7f
typedef __int64 type;
struct node//边的权和顶点
{
    int u, v;
    type w;
}edge[MAXN * MAXN];
int pre[MAXN], id[MAXN], vis[MAXN], n, m, pos;
type in[MAXN];//存最小入边权,pre[v]为该边的起点
type Directed_MST(int root, int V, int E)
{
    type ret = 0;//存最小树形图总权值
    while(true)
    {
        int i;
        //1.找每个节点的最小入边
        for( i = 0; i &lt; V; i++)
            in[i] = INF;//初始化为无穷大
        for( i = 0; i &lt; E; i++)//遍历每条边
        {
            int u = edge[i].u;
            int v = edge[i].v;
            if(edge[i].w &lt; in[v] &amp;&amp; u != v)//说明顶点v有条权值较小的入边  记录之
            {
                pre[v] = u;//节点u指向v
                in[v] = edge[i].w;//最小入边
                if(u == root)//这个点就是实际的起点
                    pos = i;
            }
        }
        for( i = 0; i &lt; V; i++)//判断是否存在最小树形图
        {
            if(i == root)
                continue;
            if(in[i] == INF)
                return -1;//除了根以外有点没有入边,则根无法到达它  说明它是独立的点 一定不能构成树形图
        }
        //2.找环
        int cnt = 0;//记录环数
        memset(id, -1, sizeof(id));
        memset(vis, -1, sizeof(vis));
        in[root] = 0;
        for( i = 0; i &lt; V; i++) //标记每个环
        {
            ret += in[i];//记录权值
            int v = i;
            while(vis[v] != i &amp;&amp; id[v] == -1 &amp;&amp; v != root)
            {
                vis[v] = i;
                v = pre[v];
            }
            if(v != root &amp;&amp; id[v] == -1)
            {
                for(int u = pre[v]; u != v; u = pre[u])
                    id[u] = cnt;//标记节点u为第几个环
                id[v] = cnt++;
            }
        }
        if(cnt == 0)
            break; //无环   则break
        for( i = 0; i &lt; V; i++)
            if(id[i] == -1)
                id[i] = cnt++;
            //3.建立新图   缩点,重新标记
            for( i = 0; i &lt; E; i++)
            {
                int u = edge[i].u;
                int v = edge[i].v;
                edge[i].u = id[u];
                edge[i].v = id[v];
                if(id[u] != id[v])
                    edge[i].w -= in[v];
            }
            V = cnt;
            root = id[root];
    }
    return ret;
}
int main()
{
    int i;
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {
        type sum = 0;
        for( i = 0; i &lt; m; i++)
        {
            scanf(&quot;%d%d%I64d&quot;, &amp;edge[i].u, &amp;edge[i].v, &amp;edge[i].w);
            edge[i].u++; edge[i].v++;
            sum += edge[i].w;
        }
      sum ++;
        for( i = m; i &lt; m + n; i++)//增加超级节点0,节点0到其余各个节点的边权相同（此题中 边权要大于原图的总边权值）
        {
            edge[i].u = 0;
            edge[i].v = i - m + 1;
            edge[i].w = sum;
        }
        type ans = Directed_MST(0, n + 1, m + n);
        //n+1为总结点数,m+n为总边数
        //ans代表以超级节点0为根的最小树形图的总权值,
        //将ans减去sum,如果差值小于sum,说明节点0的出度只有1,说明原图是连通图
        //如果差值&gt;=sum,那么说明节点0的出度不止为1,说明原图不是连通图
        if(ans == -1 || ans - sum &gt;= sum)
            puts(&quot;impossible&quot;);
        else
            printf(&quot;%I64d %d\n&quot;,ans - sum, pos - m);
        puts(&quot;&quot;);
    }
    return 0;
}
</code></pre>
<h3 id="steiner-tree">$$Steiner Tree$$</h3>
<p>掌握$$O(3<sup>{kn}+2</sup>{kmlog(m)} )$$的方法。</p>
<p><a href="https://blog.csdn.net/fengbandahe/article/details/11789977">浅析SteinerTree（斯坦纳树）</a></p>
<pre><code class="language-cpp">//POJ3123
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;map&gt;
using namespace std;
int main()
{
    int INF = 99999999, N, K, d[30][30], i, j, k, x, y, z;
	int dp[256][30], e[8], v[30], c, b;
	string s, t;
	while (cin &gt;&gt; N &gt;&gt; K &amp;&amp; N)
	{
		map &lt;string, int&gt; cityMap;
		for (i = 0; i &lt; N; i++)
		for (j = 0; j &lt; N; j++)
		d[i][j] = i == j ? 0 : INF;
		for (i = 0; i &lt; N; i++)
		{
			cin &gt;&gt; s;
			cityMap[s] = i;
		}
		if (K)
		while (cin &gt;&gt; s &gt;&gt; t &gt;&gt; z, x = cityMap[s],
			y = cityMap[t],
			d[x][y] = d[y][x] = min(d[y][x], z), --K);
		for (k = 0; k &lt; N; k++)
			for (i = 0; i &lt; N; i++)
				for (j = 0; j &lt; N; j++)
					d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
		for (i = 0; i &lt; 8; i++)
		{
			cin &gt;&gt; s;
			e[i] = cityMap[s];
			for (j = 0; j &lt; N; j++)
				dp[1 &lt;&lt; i][j] = d[j][e[i]];
		}
		for (i = 1; i &lt; 256; i++)
		{
			if (!(i &amp; (i - 1)))
			continue;	
			// step1
			for (k = 0; k &lt; N; k++)
			{
				dp[i][k] = INF;
				v[k] = 0;
				/*for (j = 1; j &lt; i; j++)
				if ((i | j) == i)
				dp[i][k] = min(dp[i][k], dp[j][k] + dp[i-j][k]);*/
				for (int sub = i; sub; sub = (sub - 1) &amp; i)
				{
					dp[i][k] = min(dp[i][k], dp[sub][k] + dp[i - sub][k]);
				}
			}
			// step2
			for (j = 0; b = INF, j &lt; N; j++)
			{
				for (k = 0; k &lt; N; k++)
					if (dp[i][k] &lt;= b &amp;&amp; !v[k])
						b = dp[i][c = k];
				for (k = 0, v[c] = 1; k &lt; N; k++)
					dp[i][c] = min(dp[i][c], dp[i][k] + d[k][c]);
			}
		}
		// step3
		for (i = 0, b = INF; z = 0, i &lt; 256; b = min(b, z), i++)
		for (j = 0; y = 0, j &lt; 4; z += !!y * dp[y][x], j++)
		for (k = 0; k &lt; 8; k += 2)
		if ((i &gt;&gt; k &amp; 3) == j)
		y += 3 &lt;&lt; k, x = e[k];
		cout &lt;&lt; b &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
<h3 id="二分图匹配">二分图匹配</h3>
<p>一般结果只与$$x，n-x，m-x，n+m-x $$有关。</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;cctype&gt;
#define maxn 20000+200
using namespace std;
inline int read(){
	register int x=0,y=0;register char ch=getchar();
	for(;!isdigit(ch);ch=getchar())if(ch=='-')y=1;
	for(;isdigit(ch);ch=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48);
	return y?-x:x; 
}
struct edge{
	int v,n;
}e[maxn];
int first[maxn],ask[maxn],matched[maxn];
int n,m,er,ans=0,num_edge=0;
inline void add(int u,int v){
	int k=++num_edge;
	e[k].n=first[u],first[u]=k,e[k].v=v;
} 
int found(int x){
	int ee,v;
	for(ee=first[x];v=e[ee].v,ee;ee=e[ee].n)
		if(!ask[v]){
			ask[v]=1;
			if(!matched[v]||found(matched[v]))
				matched[v]=x;return 1;
		}
	return 0;
}
inline void match(){
	int cnt=0;
	memset(matched,0,sizeof(matched));
	for(int i=1;i&lt;=n;++i){
		memset(ask,0,sizeof(ask));
		if(found(i))++cnt; 
	}
	ans=cnt;
}
signed main(){
	n=read(),m=read(),er=read();
	int x,y;
	for(int i=1;i&lt;=er;++i)
	{
		if(x&gt;n||y&gt;m)continue;
		x=read(),y=read(),
		add(x,y);
	}
	match();
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
</code></pre>
<h3 id="仙人掌">仙人掌</h3>
<p>任意一条边至多只出现在一条简单回路的无向连通图称为仙人掌。</p>
<pre><code class="language-cpp">//luogu-P5236
#include&lt;bits/stdc++.h&gt;
#define N 10005
#define M 80005
using namespace std;
inline void rd(int &amp;X){
    X=0;char ch=0;
    while(!isdigit(ch))ch=getchar();
    while( isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar();
}
int n,m,q,cnt=1,tot,num;
int head[N],dis[N],v[N];
struct nd{int nxt,to,v;}e[M];
int d[N],Dis[N],vis[M],pre[N],sum[M],c[N],f[N][15];
#define For(x) for(int y,i=head[x];(y=e[i].to);i=e[i].nxt)
inline void add(int x,int y,int v){
    e[++cnt]={head[x],y,v};head[x]=cnt;
    e[++cnt]={head[y],x,v};head[y]=cnt;
}
void SPFA(){
    queue&lt;int&gt; q;q.push(1);
    memset(dis,0x3f,sizeof dis);dis[1]=dis[0]=0;
    while(q.size()){
        int x=q.front();q.pop();v[x]=0;
        For(x) if(dis[y]&gt;dis[x]+e[i].v){
            dis[y]=dis[x]+e[i].v;
            if(!v[y]) v[y]=1,q.push(y);
        }
    }
}
void work(int x,int rt){
    if(x==rt) return ;
    add(rt,x,0);vis[pre[x]]=vis[pre[x]^1]=1;
    sum[num]+=e[pre[x]].v;c[x]=num;work(e[pre[x]^1].to,rt);
}
void dfs(int x){
    v[x]=++tot;
    For(x) if(i^pre[x]^1)
        if(!v[y]) pre[y]=i,Dis[y]=Dis[x]+e[i].v,dfs(y);
        else if(v[y]&lt;v[x]) {
            sum[++num]=e[i].v;
            vis[i]=vis[i^1]=1; work(x,y);
        }
}
void dfs2(int x){
    for(int i=1;i&lt;=14;i++)
        f[x][i]=f[f[x][i-1]][i-1];
    For(x) if(!vis[i] and y!=f[x][0])
        d[y]=d[x]+1,f[y][0]=x,dfs2(y);
}
int ask(int x=0,int y=0){
    rd(x);rd(y);
    if(d[x]&lt;d[y]) swap(x,y);
    int X=x,Y=y;
    for(int i=14;~i;i--)
        if(d[f[x][i]]&gt;=d[y])
            x=f[x][i];
    if(x==y) return dis[X]-dis[Y];
    for(int i=14;~i;i--)
        if(f[x][i]!=f[y][i])
            x=f[x][i],y=f[y][i];
    if(c[x] and c[x]==c[y]){
        int now=sum[c[x]],L=abs(Dis[x]-Dis[y]);
        return min(L,now-L)+dis[X]-dis[x]+dis[Y]-dis[y];
    }return dis[X]+dis[Y]-2*dis[f[x][0]];
}
signed main(){
    rd(n);rd(m);rd(q);
    for(int x,y,v,i=1;i&lt;=m;i++)
        rd(x),rd(y),rd(v),add(x,y,v);
    SPFA();dfs(1);dfs2(1);
    while(q--) printf(&quot;%d\n&quot;,ask());
}
</code></pre>
<h3 id="平面图">平面图</h3>
<p>对于一个图G=&lt; V,E &gt;,如果能把G画在一个平面上,且画出的图的任意两条边除了V中的节点没有其他交点,则图G为平面图.</p>
<pre><code class="language-cpp">//HNOI2010 Planar平面图判定
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
const int MAXE=10010;
const int MAXV=300;
struct node
{
       int x,y;
}e2[MAXE];
int test,n,m,sum;
int h[MAXV],rank[MAXV],c[MAXV];
bool map[MAXV][MAXV],flag;
vector&lt;int&gt; e[MAXE],dag[MAXE];
vector&lt;int&gt;::iterator it;
bool Fright(int x1,int y1,int x2,int y2)
{
     if (x1==x2 || x1==y2 || y1==x2 || y1==y2) return 0;
     x1=rank[x1],y1=rank[y1];
     x2=rank[x2],y2=rank[y2];
     if (x1&gt;y1) swap(x1,y1);
     return (x1&lt;x2 &amp;&amp; x2&lt;y1)!=(x1&lt;y2 &amp;&amp; y2&lt;y1);
}
void Colour(int v,int x)
{
 c[v]=x;
     int size=dag[v].size();
     for (int i=0;i&lt;size;++i)
     {
 if (!c[dag[v][i]]) Colour(dag[v][i],-x); else
         if (c[dag[v][i]]==x) flag=0;
         if (!flag) return;
     }
}
int main()
{
    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);
    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d&quot;,&amp;test);
    while (test--)
    {
          scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
          flag=1;
          for (int i=1;i&lt;=n;++i) e[i].clear();
          for (int i=1;i&lt;=m;++i)
          {
              int x,y;
              scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
              e[x].push_back(y);
          }
          for (int i=1;i&lt;=n;++i)
              scanf(&quot;%d&quot;,&amp;h[i]),rank[h[i]]=i;
          memset(map,0,sizeof(map));
          for (int i=2;i&lt;=n;++i)
              map[h[i-1]][h[i]]=map[h[i]][h[i-1]]=1;
          map[h[n]][h[1]]=map[h[1]][h[n]]=1;
          if (m&gt;n*3-6)
          {
                      printf(&quot;NO\n&quot;);
                      continue;
          }
          sum=0;
          for (int i=1;i&lt;=n;++i)
              for (it=e[i].begin();it&lt;e[i].end();++it)
                  if (!map[i][*it]) e2[++sum].x=i,e2[sum].y=*it;
 for (int i=1;i&lt;=sum;++i) dag[i].clear();
          for (int i=1;i&lt;=sum;++i)
              for (int j=i+1;j&lt;=sum;++j)
                  if (Fright(e2[i].x,e2[i].y,e2[j].x,e2[j].y)) dag[i].push_back(j),dag[j].push_back(i);
 memset(c,0,sizeof(c));
          for (int i=1;i&lt;=sum;++i)
              if (!c[i])
              {
                        Colour(i,1);
 if (!flag) break;
              }
          if (flag) printf(&quot;YES\n&quot;); else printf(&quot;NO\n&quot;);
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Splay维护序列]]></title>
        <id>https://https://luxin-oi.github.io/post/splay-wei-hu-xu-lie/</id>
        <link href="https://https://luxin-oi.github.io/post/splay-wei-hu-xu-lie/">
        </link>
        <updated>2020-03-04T17:08:22.000Z</updated>
        <content type="html"><![CDATA[<pre><code>/*
 * @Author: luxin 
 * @Date: 2020-02-08 14:43:55 
 * @Last Modified by: luxin
 * @Last Modified time: 2020-02-20 20:37:51
 */
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cctype&gt;
#include &lt;cmath&gt;
using namespace std;
#define I inline
#define R register
#define inf 107374282
#define FOR(i,begin,end) for(R int i=begin;i&lt;=end;++i)
#define ROF(i,begin,end) for(R int i=begin;i&gt;=end;--i)
#define maxn 1000010
#define tagnone 10000110
int a[maxn],n,m;
struct luna{
    int child[2],parent,size,sum,value,left,right,mid,rev,tag;
    I void clear(){child[1]=child[0]=parent=value=rev=0,tag=tagnone;}
}tr[maxn];
#define ls tr[o].child[0]
#define rs tr[o].child[1]
int id[maxn],cnt,rub[maxn],top,root;
I int rubbish(){
    return top?rub[top--]:++cnt;
}
I void change_value(int o,int val){
    if(!o)return;
    tr[o].tag=tr[o].value=val,
    tr[o].sum=val*tr[o].size,
    tr[o].left=tr[o].right=max(0,tr[o].sum),
    tr[o].mid=max(tr[o].sum,tr[o].value);
}
I void change_rev(int o){
    swap(ls,rs);
    swap(tr[o].left,tr[o].right);
    tr[o].rev^=1;
}
I void pushup(int o){
    luna&amp;x=tr[ls],
        &amp;y=tr[rs],
        &amp;res=tr[o];
    res.sum=x.sum+y.sum+res.value;
    res.size=x.size+y.size+1;
    res.right=max(y.right,x.right+res.value+y.sum);
    res.left=max(x.left,y.left+res.value+x.sum);
    res.mid=max(max(x.mid,y.mid),x.right+y.left+res.value);
}
I void pushdown(int o){
    if(tr[o].tag!=tagnone){
        change_value(ls,tr[o].tag);
        change_value(rs,tr[o].tag);
        tr[o].tag=tagnone;
    }
    if(tr[o].rev){
        change_rev(ls);
        change_rev(rs);
        tr[o].rev=0;
    }
}
I bool identify(int o){
    return tr[tr[o].parent].child[1]==o;
}
I void connect(int o,int pa,bool flag){
    tr[o].parent=pa;
    tr[pa].child[flag]=o;
}
I void rotate(int x){
    int y=tr[x].parent;
    int r=tr[y].parent;
    bool flag_x=identify(x);
    bool flag_y=identify(y);
    int b=tr[x].child[!flag_x];
    connect(b,y,flag_x);
    connect(y,x,!flag_x);
    connect(x,r,flag_y);
    pushup(y),pushup(x);
}
I void splay(int at,int to){
    while(tr[at].parent!=to){
        int pa=tr[at].parent;
        if(tr[pa].parent!=to)
            identify(at)==identify(pa)?rotate(pa):rotate(at);
            rotate(at);
    }
    if(!to)root=at;
}
I void New(int o,int val){
    tr[o].mid=tr[o].sum=val;
    tr[o].tag=tagnone;
    tr[o].rev=0;
    tr[o].left=tr[o].right=max(val,0);
    tr[o].size=1;
    tr[o].value=val;
}
I void build(int l,int r,int fa){
    int mid=(l+r)&gt;&gt;1;
    int o=id[mid],pre=id[fa];
    if(l==r)New(o,a[l]);
    if(l&lt;mid)build(l,mid-1,mid);
    if(r&gt;mid)build(mid+1,r,mid);
    tr[o].value=a[mid],tr[o].parent=pre,tr[o].tag=tagnone;
    pushup(o);
    tr[pre].child[mid&gt;=fa]=o;
}
I int kth(int x){
    int o=root;
    while(233){
        pushdown(o);
        if(tr[ls].size&gt;=x)o=ls;
        else{
            if(tr[ls].size+1==x)return o;
            else x-=tr[ls].size+1,o=rs;
        }
    }
    return inf;
}
I void remove(int o){
    if(ls)remove(ls);
    if(rs)remove(rs);
    rub[++top]=o;
    tr[o].clear();
}
I int split(int k,int len){
    int x=kth(k),y=kth(k+len+1);
    splay(x,0),splay(y,x);
    return tr[y].child[0];
}
I void query(int k,int len){
    int node=split(k,len);
    printf(&quot;%d\n&quot;,tr[node].sum);
}
I void update(int x,int len,int val){
    int o=split(x,len);
    int y=tr[o].parent;
    change_value(o,val);
    pushup(y),pushup(tr[y].parent);
}
I void reverse(int x,int len){   
    int o=split(x,len);
    int y=tr[o].parent;
    change_rev(o);
    pushup(y),pushup(tr[y].parent);
}
I void eraser(int x,int len){
    int o=split(x,len);
    int y=tr[o].parent;
    remove(o);
    tr[y].child[0]=0;
    pushup(y),pushup(tr[y].parent);
}
I void insert(int k,int len){
    for(int i=1;i&lt;=len;++i)
        scanf(&quot;%d&quot;,&amp;a[i]),
        id[i]=rubbish();
    build(1,len,0);
    int z=id[(1+len)&gt;&gt;1];
    int x=kth(k+1),y=kth(k+2);
    splay(x,0),splay(y,x);
    tr[y].child[0]=z;
    tr[z].parent=y;
    pushup(y),pushup(tr[y].parent);
}
#define online
signed main(){
#ifndef online
    freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;test.out&quot;,&quot;w&quot;,stdout);
#endif
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    tr[0].mid=a[1]=a[n+2]=-inf;
    for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;a[i+1]);
    for(int i=1;i&lt;=n+2;++i)id[i]=i;
    build(1,n+2,0);
    root=(n+3)&gt;&gt;1;
    cnt=n+2;
    for(int i=1;i&lt;=m;++i){
        string s;int x,len,y;
        cin&gt;&gt;s;
        if(s!=&quot;MAX-SUM&quot;)scanf(&quot;%d%d&quot;,&amp;x,&amp;len);
        else printf(&quot;%d\n&quot;,tr[root].mid);
        if(s==&quot;INSERT&quot;)insert(x,len);
        if(s==&quot;DELETE&quot;)eraser(x,len);
        if(s==&quot;MAKE-SAME&quot;)
            scanf(&quot;%d&quot;,&amp;y),update(x,len,y);
        if(s==&quot;REVERSE&quot;)reverse(x,len);
        if(s==&quot;GET-SUM&quot;)query(x,len);
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最小圆覆盖（随机增量）]]></title>
        <id>https://https://luxin-oi.github.io/post/zui-xiao-yuan-fu-gai-sui-ji-zeng-liang/</id>
        <link href="https://https://luxin-oi.github.io/post/zui-xiao-yuan-fu-gai-sui-ji-zeng-liang/">
        </link>
        <updated>2020-03-04T17:06:34.000Z</updated>
        <content type="html"><![CDATA[<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cctype&gt;
#include &lt;cmath&gt;
using namespace std;
#define I inline
#define R register
#define inf 1073742823
#define FOR(i,begin,end) for(R int i=begin;i&lt;=end;++i)
#define ROF(i,begin,end) for(R int i=begin;i&gt;=end;--i)

const double eps=1e-10;
const double pi=acos(-1.0);
I int dcmp(double x)
{   if(fabs(x)&lt;eps)return 0;
    else return x&lt;0?-1:1;}
#define P point
#define PP const P &amp;
struct point{
    double x,y;
    I P(const double &amp;_x=0,const double &amp;_y=0):x(_x),y(_y){}
    I bool operator ==(PP a)const{return dcmp(x-a.x)==0&amp;&amp;dcmp(y-a.y)==0;}
    I bool operator&lt;(PP a)const{return x&lt;a.x||(x==a.x&amp;&amp;y&lt;a.y);}
    I P operator+(PP a)const{return P(x+a.x,y+a.y);}
    I P operator-(PP a)const{return P(x-a.x,y-a.y);}
    I P operator*(const double a)const{return P(x*a,y*a);}
    I P operator/(const double a)const{return P(x/a,y/a);}
    I P operator*(PP a)const{return P(x*a.x-y*a.y,x*a.y+y*a.x);}
    I double len()const{return sqrt(x*x+y*y);}
    I double len2()const{return x*x+y*y;}
    I P rotate(const double theta)const{return P(x,y)*P(cos(theta),sin(theta));}
    I double operator|(PP a)const{return x*a.x+y*a.y;}
    I double operator&amp;(PP a)const{return x*a.y-y*a.x;}
    I P norm(){return *this/len();}
    I double angle(PP a)const{return *this|a/len()/a.len();}
}p[1000005];
typedef point vec;

struct line{
    P a,b;
    I line(PP _a=P(0,0),PP _b=P(0,0)):a(_a),b(_b){}
    I P cross(const line &amp;A){
        return a+(b-a)*((A.b-A.a)&amp;(a-A.a))/((b-a)&amp;(A.b-A.a));
    }
};

P circle(PP a,PP b,PP c){
    P A=(a+b)/2,B=(a+c)/2;
    vec k1=b-a,k2=c-a;
    k1=k1.rotate(pi/2),k2=k2.rotate(pi/2);
    line l1=line(A,A+k1),l2=line(B,B+k2);
    return l1.cross(l2);
}

int n;

signed main(){
    scanf(&quot;%d&quot;,&amp;n);
    FOR(i,1,n)scanf(&quot;%lf%lf&quot;,&amp;p[i].x,&amp;p[i].y);
    random_shuffle(p+1,p+n+1);
    P o;double r2=0;
    FOR(i,1,n)
        if((p[i]-o).len2()&gt;r2){
            o=p[i],r2=0;
            FOR(j,1,i-1)
            if((p[j]-o).len2()&gt;r2){
                o=(p[i]+p[j])/2,r2=(p[j]-o).len2();
                FOR(k,1,j-1)
                    if((p[k]-o).len2()&gt;r2)
                        o=circle(p[i],p[j],p[k]),r2=(p[k]-o).len2();
            }
        }
    printf(&quot;%.10lf\n%.10lf %.10lf\n&quot;, sqrt(r2), o.x, o.y);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[旋转卡壳]]></title>
        <id>https://https://luxin-oi.github.io/post/xuan-zhuan-qia-ke/</id>
        <link href="https://https://luxin-oi.github.io/post/xuan-zhuan-qia-ke/">
        </link>
        <updated>2020-03-04T17:05:30.000Z</updated>
        <content type="html"><![CDATA[<pre><code>// p1452
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cctype&gt;
#include &lt;cmath&gt;
using namespace std;
#define I inline
#define R register
#define inf 1073742823
#define FOR(i,begin,end) for(R int i=begin;i&lt;=end;++i)
#define ROF(i,begin,end) for(R int i=begin;i&gt;=end;--i)

const int maxn = 200000+20;

const double eps=1e-10;
const double pi=acos(-1.0);
I int dcmp(double x)
{   if(fabs(x)&lt;eps)return 0;
    else return x&lt;0?-1:1;}
#define P point
#define PP const P &amp;
struct point{
    double x,y;
    I P(const double &amp;_x=0,const double &amp;_y=0):x(_x),y(_y){}
    I bool operator ==(PP a)const{return dcmp(x-a.x)==0&amp;&amp;dcmp(y-a.y)==0;}
    I bool operator&lt;(PP a)const{return x&lt;a.x||(x==a.x&amp;&amp;y&lt;a.y);}
    I P operator+(PP a)const{return P(x+a.x,y+a.y);}
    I P operator-(PP a)const{return P(x-a.x,y-a.y);}
    I P operator*(const double a)const{return P(x*a,y*a);}
    I P operator/(const double a)const{return P(x/a,y/a);}
    I P operator*(PP a)const{return P(x*a.x-y*a.y,x*a.y+y*a.x);}
    I double len()const{return sqrt(x*x+y*y);}
    I double len2()const{return x*x+y*y;}
    I P rotate(const double theta)const{return P(x,y)*P(cos(theta),sin(theta));}
    I double operator|(PP a)const{return x*a.x+y*a.y;}
    I double operator&amp;(PP a)const{return x*a.y-y*a.x;}
    I P norm(){return *this/len();}
    I double angle(PP a)const{return *this|a/len()/a.len();}
}p[maxn],s[maxn];
int n,top;
typedef point vec;

I bool cmp(PP a,PP b){
    vec p1=a-p[1],p2=b-p[1];
    double k=(p1)&amp;(p2);
    if(dcmp(k)==1)return 1;
    if(dcmp(k)==0&amp;&amp;p1.len2()&lt;p2.len2())return 1;
    return 0;
}

signed main(){
    scanf(&quot;%d&quot;,&amp;n);
    FOR(i,1,n){
        scanf(&quot;%lf%lf&quot;,&amp;p[i].x,&amp;p[i].y);
        if(p[i]&lt;p[1])swap(p[1],p[i]);
    }
    sort(p+2,p+1+n,cmp);
    s[top=1]=p[1];
    FOR(i,2,n){
        while(top&gt;1&amp;&amp;(dcmp((s[top]-s[top-1])&amp;(p[i]-s[top])))&lt;=0)top--;
        s[++top]=p[i];
    }
    s[0]=s[top];
    int j=2;
    double ans=0;
    for(int i=0;i&lt;top;++i){
        while(((s[i + 1] - s[i]) &amp; (s[j] - s[i])) &lt; ((s[i + 1] - s[i]) &amp; (s[j + 1] - s[i])))j=(j+1)%n;
        ans=max(ans, max((s[i+1]-s[j]).len2(),(s[i]-s[j]).len2()));
    }
    printf(&quot;%d&quot;,(int)ans);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二维凸包]]></title>
        <id>https://https://luxin-oi.github.io/post/er-wei-tu-bao/</id>
        <link href="https://https://luxin-oi.github.io/post/er-wei-tu-bao/">
        </link>
        <updated>2020-03-04T17:04:22.000Z</updated>
        <content type="html"><![CDATA[<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cctype&gt;
#include &lt;cmath&gt;
using namespace std;
#define I inline
#define R register
#define inf 1073742823
#define FOR(i,begin,end) for(R int i=begin;i&lt;=end;++i)
#define ROF(i,begin,end) for(R int i=begin;i&gt;=end;--i)

const int maxn = 200000+20;

const double eps=1e-10;
const double pi=acos(-1.0);
I int dcmp(double x)
{   if(fabs(x)&lt;eps)return 0;
    else return x&lt;0?-1:1;}
#define P point
#define PP const P &amp;
struct point{
    double x,y;
    I P(const double &amp;_x=0,const double &amp;_y=0):x(_x),y(_y){}
    I bool operator ==(PP a)const{return dcmp(x-a.x)==0&amp;&amp;dcmp(y-a.y)==0;}
    I bool operator&lt;(PP a)const{return x&lt;a.x||(x==a.x&amp;&amp;y&lt;a.y);}
    I P operator+(PP a)const{return P(x+a.x,y+a.y);}
    I P operator-(PP a)const{return P(x-a.x,y-a.y);}
    I P operator*(const double a)const{return P(x*a,y*a);}
    I P operator/(const double a)const{return P(x/a,y/a);}
    I P operator*(PP a)const{return P(x*a.x-y*a.y,x*a.y+y*a.x);}
    I double len()const{return sqrt(x*x+y*y);}
    I double len2()const{return x*x+y*y;}
    I P rotate(const double theta)const{return P(x,y)*P(cos(theta),sin(theta));}
    I double operator|(PP a)const{return x*a.x+y*a.y;}
    I double operator&amp;(PP a)const{return x*a.y-y*a.x;}
    I P norm(){return *this/len();}
    I double angle(PP a)const{return *this|a/len()/a.len();}
}p[maxn],s[maxn];
int n,top;
typedef point vec;

I bool cmp(PP a,PP b){
    vec p1=a-p[1],p2=b-p[1];
    double k=(p1)&amp;(p2);
    if(dcmp(k)==1)return 1;
    if(dcmp(k)==0&amp;&amp;p1.len2()&lt;p2.len2())return 1;
    return 0;
}

signed main(){
    scanf(&quot;%d&quot;,&amp;n);
    FOR(i,1,n){
        scanf(&quot;%lf%lf&quot;,&amp;p[i].x,&amp;p[i].y);
        if(p[i]&lt;p[1])swap(p[1],p[i]);
    }
    sort(p+2,p+1+n,cmp);
    s[top=1]=p[1];
    FOR(i,2,n){
        while(top&gt;1&amp;&amp;(dcmp((s[top]-s[top-1])&amp;(p[i]-s[top])))&lt;=0)top--;
        s[++top]=p[i];
    }
    s[0]=s[top];
    double ans=0;
    FOR(i,1,top)
        ans+=(s[i]-s[i-1]).len();
    printf(&quot;%.2lf&quot;,ans);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Dinic]]></title>
        <id>https://https://luxin-oi.github.io/post/dinic/</id>
        <link href="https://https://luxin-oi.github.io/post/dinic/">
        </link>
        <updated>2020-03-04T17:02:58.000Z</updated>
        <content type="html"><![CDATA[<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cctype&gt;
#include &lt;cmath&gt;

using namespace std;
#define I inline
#define R register
#define inf 1073742823
#define FOR(i,begin,end) for(R int i=begin;i&lt;=end;++i)
#define ROF(i,begin,end) for(R int i=begin;i&gt;=end;--i)

namespace IO{
    char buf[1&lt;&lt;21],*pa=buf,*pb=buf;
    char buffer[1&lt;&lt;21];int p1=-1;const int p2=(1&lt;&lt;21)-1; 
    I char gc(){return pa==pb&amp;&amp;(pb=(pa=buf)+fread(buf,1,1&lt;&lt;21,stdin),pa==pb)?EOF:*pa++;}
    template&lt;class T&gt;I void read(T &amp;x){
        x=0;R int y=0;R char ch=gc();
        for(;!isdigit(ch);ch=gc())y=ch=='-';
        for(;isdigit(ch);ch=gc())x=x*10+(ch^48);
        (y)&amp;&amp;(x=-x);return;}
    I void flush(){fwrite(buffer,1,p1+1,stdout);p1=-1;return;}
    I void pc(int ch){if(p1==p2)flush();buffer[++p1]=ch;return;}
    template&lt;class T&gt;I void write(T x){
        static char buf[20];static int len =-1;
        if(x&gt;=0){do buf[++len]=(x%10)^48,x/=10;while(x);}
        else{pc('-');do buf[++len]=(-(x%10))^48,x/=10;while(x);}
        while(len&gt;=0)pc(buf[len--]);
        return;}
}
using namespace IO;

const int maxn = 50000+50;
const int maxm = 200000+200;
#define Ci const int &amp;

int n,m,s,t;

struct edge{
    int u,v,n,flow;
    I edge(Ci _u=0,Ci _v=0,Ci _n=0,Ci _flow=0):u(_u),v(_v),n(_n),flow(_flow){}
}e[maxm];
int cnt=1,head[maxn],cur[maxn];
I void add(Ci u,Ci v,Ci flow){
    e[++cnt]=edge(u,v,head[u],flow),head[u]=cnt;
    e[++cnt]=edge(v,u,head[v],0),head[v]=cnt;
}

int dep[maxn];
#include&lt;queue&gt;
I bool bfs(){
    queue&lt;int&gt;q;
    memset(dep,0,sizeof dep);
    memcpy(cur,head,sizeof(head));
    dep[s]=1,q.push(s);
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int ee=head[u],v;v=e[ee].v,ee;ee=e[ee].n)
            if(e[ee].flow&amp;&amp;dep[v]==0)
                dep[v]=dep[u]+1,q.push(v);
    }
    return dep[t];
}
int dfs(int u,int limit){
    if(limit==0||u==t)return limit;
    int flow=0,f;
    for(int ee=cur[u],v;cur[u]=ee,v=e[ee].v,ee;ee=e[ee].n)
        if(dep[v]==dep[u]+1&amp;&amp;(f=dfs(v,min(limit,e[ee].flow)))){
            flow+=f;
            limit-=f;
            e[ee].flow-=f;
            e[ee^1].flow+=f;
            if(!limit)break;
        }
    return flow;
}
I int dinic(){
    int ans=0;
    while(bfs())
            ans+=dfs(s,inf);
        return ans;
}
signed main(){
    read(n),read(m),read(s),read(t);
    int u,v,f;
    FOR(i,1,m)
        read(u),read(v),read(f),
        add(u,v,f);
    write(dinic());
    flush();
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ISAP]]></title>
        <id>https://https://luxin-oi.github.io/post/isap/</id>
        <link href="https://https://luxin-oi.github.io/post/isap/">
        </link>
        <updated>2020-03-04T17:01:15.000Z</updated>
        <content type="html"><![CDATA[<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cctype&gt;
#include &lt;cmath&gt;
using namespace std;
#define I inline
#define R register
#define inf 1073742823
#define FOR(i,begin,end) for(R int i=begin;i&lt;=end;++i)
#define ROF(i,begin,end) for(R int i=begin;i&gt;=end;--i)
#include&lt;queue&gt;
namespace IO{
    char buf[1&lt;&lt;21],*pa=buf,*pb=buf;
    char buffer[1&lt;&lt;21];int p1=-1;const int p2=(1&lt;&lt;21)-1; 
    I char gc(){return pa==pb&amp;&amp;(pb=(pa=buf)+fread(buf,1,1&lt;&lt;21,stdin),pa==pb)?EOF:*pa++;}
    template&lt;class T&gt;I void read(T &amp;x){
        x=0;R int y=0;R char ch=gc();
        for(;!isdigit(ch);ch=gc())y=ch=='-';
        for(;isdigit(ch);ch=gc())x=x*10+(ch^48);
        (y)&amp;&amp;(x=-x);return;}
    I void flush(){fwrite(buffer,1,p1+1,stdout);p1=-1;return;}
    I void pc(int ch){if(p1==p2)flush();buffer[++p1]=ch;return;}
    template&lt;class T&gt;I void write(T x){
        static char buf[20];static int len =-1;
        if(x&gt;=0){do buf[++len]=(x%10)^48,x/=10;while(x);}
        else{pc('-');do buf[++len]=(-(x%10))^48,x/=10;while(x);}
        while(len&gt;=0)pc(buf[len--]);
        return;}
}
using namespace IO;
int n,m,s,t;
const int maxn = 50000+50;
const int maxm = 200000+200;
#define ci const int &amp;
struct edge{
    int u,v,f,n;
    I edge(ci uu =0,ci vv=0,ci ff=0,ci nn=0):u(uu),v(vv),f(ff),n(nn){}

}e[maxm];
int cnt=1,head[maxn],cur[maxn],gap[maxn],dis[maxn],mxflow=0;
I void add(ci u,ci v,ci f){
    e[++cnt]=edge(u,v,f,head[u]),head[u]=cnt;
    e[++cnt]=edge(v,u,0,head[v]),head[v]=cnt;
}
I void bfs(){
    queue&lt;int&gt;q;q.push(t),gap[dis[t]=1]++;
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int ee=head[u],v;v=e[ee].v,ee;ee=e[ee].n)
        if(!dis[v])gap[dis[v]=dis[u]+1]++,q.push(v);
    }
}
int dfs(ci u,ci flow){
    if(u==t&amp;&amp;((mxflow+=flow)||1))return flow;
    int us=0,f;
    for(int ee=cur[u],v;cur[u]=ee,v=e[ee].v,ee;ee=e[ee].n)
        if(dis[v]==dis[u]-1){
            if(f=dfs(v,min(flow-us,e[ee].f)))
                e[ee].f-=f,e[ee^1].f+=f,us+=f;
            if(us==flow)return flow;
        }
    (--gap[dis[u]])?(++gap[++dis[u]]):dis[s]=n+1;
    return us;
}
signed main(){
    int u,v,f;
    read(n),read(m),read(s),read(t);
    FOR(i,1,m)read(u),read(v),read(f),add(u,v,f);
    bfs();
    while(dis[s]&lt;=n+1)memcpy(cur,head,sizeof head),dfs(s,inf);
    write(mxflow);
    flush();
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Miller_Rabin]]></title>
        <id>https://https://luxin-oi.github.io/post/miller_rabin/</id>
        <link href="https://https://luxin-oi.github.io/post/miller_rabin/">
        </link>
        <updated>2020-03-04T16:57:53.000Z</updated>
        <content type="html"><![CDATA[<h3 id="miller_rabin"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>i</mi><mi>l</mi><mi>l</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">Miller</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>_<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>a</mi><mi>b</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Rabin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span></h3>
<h3 id="理论基础">理论基础</h3>
<h4 id="费马小定理ap-1equiv-1mod-p">费马小定理：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>≡</mo><mn>1</mn><mo>(</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">a^{p-1}\equiv 1(\mod p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></h4>
<p>证明如下:考虑<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>p</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1,2,3,...,p-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>这<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个数字，同时乘<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>，得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mn>2</mn><mi>a</mi><mo separator="true">,</mo><mn>3</mn><mi>a</mi><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mo>(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a,2a,3a,...,(p-1)a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault">a</span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∵</mo><mi>a</mi><mo>≡</mo><mi>b</mi><mo>(</mo><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo>)</mo><mo separator="true">,</mo><mi>gcd</mi><mo>⁡</mo><mo>(</mo><mi>c</mi><mo separator="true">,</mo><mi>p</mi><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\because a \equiv b (\mod p),\gcd(c,p)=1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∵</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">(</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span style="margin-right:0.01389em;">g</span>cd</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∴</mo><mi>a</mi><mi>c</mi><mo>≡</mo><mi>b</mi><mi>c</mi><mo>(</mo><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\therefore ac\equiv bc(\mod p)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∴</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∴</mo><munderover><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></munderover><mi>i</mi><mo>≡</mo><munderover><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></munderover><mo>(</mo><mi>i</mi><mo>∗</mo><mi>a</mi><mo>)</mo><mo>(</mo><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\therefore \prod\limits_{i=1}^{p-1}i\equiv\prod\limits_{i=1}^{p-1}(i*a)(\mod p)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∴</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.12589em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8482210000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span><span style="top:-4.347113em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.12589em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8482210000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span><span style="top:-4.347113em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mopen">(</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∴</mo><mo>(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>!</mo><mo>≡</mo><mo>(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>!</mo><msup><mi>a</mi><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>(</mo><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\therefore (p-1)!\equiv (p-1)! a^{p-1}(\mod p)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∴</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">!</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∵</mo><mi>gcd</mi><mo>⁡</mo><mo>(</mo><mo>(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>!</mo><mo separator="true">,</mo><mi>p</mi><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\because \gcd ((p-1)!,p) = 1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∵</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span style="margin-right:0.01389em;">g</span>cd</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">!</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∴</mo><msup><mi>a</mi><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>≡</mo><mn>1</mn><mo>(</mo><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\therefore a^{p-1} \equiv 1(\mod p)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∴</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.864108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></span></p>
<p>（第三行成立是因为两边同为mod p的一个完全剩余系）</p>
<h4 id="二次探测-pin-primeand0xp则方程x2-equiv-1mod-p的解为x1或xp-1">二次探测 ： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>∈</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo>&amp;</mo><mn>0</mn><mo>&lt;</mo><mi>x</mi><mo>&lt;</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">p\in prime\And0&lt;x&lt;p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">&amp;</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>，则方程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>≡</mo><mn>1</mn><mo>(</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">x^2 \equiv 1(\mod p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span>的解为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>p</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x=p-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></h4>
<p>证明如下：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∵</mo><msup><mi>x</mi><mn>2</mn></msup><mo>≡</mo><mn>1</mn><mo>(</mo><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\because x^2 \equiv 1 (\mod p)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∵</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∴</mo><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mn>1</mn><mo>≡</mo><mn>0</mn><mo>(</mo><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\therefore x^2-1 \equiv 0 (\mod p)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∴</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mopen">(</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∴</mo><mi>p</mi><mi mathvariant="normal">∣</mi><mo>(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\therefore p|(x-1)(x+1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∴</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord">∣</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∵</mo><mi>p</mi><mo>∈</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>m</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">\because p \in prime
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∵</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∴</mo><mi>x</mi><mo>=</mo><mn>1</mn><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo>=</mo><mi>p</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\therefore x=1||x=p-1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∴</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<h3 id="算法流程">算法流程</h3>
<p>(1) 特判出一定的合数和素数；</p>
<p>(2)设测试的数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>,取质数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>，设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo separator="true">,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">s,k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>,满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mi>s</mi></msup><mo>∗</mo><mi>k</mi><mo>=</mo><mi>x</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a^s*k=x-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>；</p>
<p>(3)计算出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mi>t</mi></msup></mrow><annotation encoding="application/x-tex">a^t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7935559999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span></span></span></span></span></span></span>，然后不断地平方并且进行二次探测(k次)；</p>
<p>(4)根据费马小定理，如果最后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>x</mi><mo>−</mo><mn>1</mn></mrow></msup><mpadded width="0px"><mo></mo></mpadded><mo>≡</mo><mn>1</mn><mo>(</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">a^{x-1}\not\equiv 1(\mod x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>，则说明<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>为合数；</p>
<p>(5)多次取不同的a进行测试（a可以为指定质数，也可以为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mo>(</mo><mo>)</mo><mi mathvariant="normal">%</mi><mo>(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">rand()\%(x-1)+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord">%</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<h3 id="代码实现">代码实现</h3>
<p>以下代码是与随机化无关的$miller $_ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>a</mi><mi>b</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">rabin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span></p>
<pre><code class="language-c++">/*
 * @Author: luxin 
 * @Date: 2020-02-07 14:18:35 
 * @Last Modified by: luxin
 * @Last Modified time: 2020-02-07 14:32:46
 */
typedef long long ll;
const ll p[]={2,3,5,7,11,13,17,19};
ll qpow(ll x,ll a,ll mod){
    __int128 ans=1;
    for(;a;a&gt;&gt;=1,x=((__int128)x)*x%mod);
        if(a&amp;1)ans=ans*x%mod;
    return ans;
}
bool miller_rabin(ll x){
    if(x==2||x==3||x==5||x==7||x==11||x==13||x==17||x==19)return 1;
    if(x%2==0||x%3==0||x%5==0||x%7==0||x%9==0||x%11==0||x%13==0||x%17==0||x%19==0)return 0;
    ll t=x-1;int k;
    for(k=0;!(t&amp;1);t&gt;&gt;=1,++k);
    for(int i=0;i&lt;8;++i){
        ll a=p[i];;
        ll last=qpow(a,t,x);
        for(int j=1;j&lt;=k;++j)
        {
            ll now=(__int128)last*last%x;
            if(now==1&amp;&amp;last!=x-1&amp;&amp;last!=1)return 0;
            last=now;
            if(now==1)break;
        }
        if(last!=1)return 0;
    }
    return 1;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网站站呀]]></title>
        <id>https://https://luxin-oi.github.io/post/wang-zhan-zhan/</id>
        <link href="https://https://luxin-oi.github.io/post/wang-zhan-zhan/">
        </link>
        <updated>2020-03-04T15:58:24.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://csacademy.com/app/graph_editor/">graph editor</a></p>
<p><a href="https://www.desmos.com/calculator">Desmos</a></p>
<p><a href="http://oeis.org/?language=chineseS">OEIS</a></p>
<p><a href="https://www.mdeditor.com/">Mdeditor</a></p>
<p><a href="https://carbon.now.sh/">Carbon</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color">Color</a></p>
<p><a href="https://oi-archive.memset0.cn/">oi-archive</a></p>
<p><a href="https://oi-wiki.org/">OI-wiki</a></p>
<p><a href="https://www.luogu.com.cn/blog/IowaBattleship/latex-gong-shi-tai-quan">Latex</a></p>
<p><a href="https://www.runoob.com/">菜鸟教程</a></p>
<p><a href="https://projecteuler.net/archives">Project Euler</a></p>
<p><a href="https://trello.com/b/pDFlBKeg/oi%E7%BB%BC%E5%90%88%E9%A2%98%E5%8D%95">OI题单</a></p>
<p><a href="https://www.geogebra.org/geometry">geometry</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[THUWC2016 定向越野]]></title>
        <id>https://https://luxin-oi.github.io/post/thuwc2016-ding-xiang-yue-ye/</id>
        <link href="https://https://luxin-oi.github.io/post/thuwc2016-ding-xiang-yue-ye/">
        </link>
        <updated>2020-03-03T07:52:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="thuwc2016-定向越野markdown-炸了">THUWC2016 定向越野（markdown 炸了）</h1>
<h2 id="题目描述">题目描述：</h2>
<h3 id="题面">题面：</h3>
<p>定向越野是一项集智力与体力为一体的体育运动，在这项活动中，选手需要从起点出发，在尽可能短的时间内到达指定的地点。</p>
<p>牛牛非常喜爱这项运动，但是他不知道怎么样才能更快到达终点。他听说来参加集训的你智力过人，于是他把定向越野的地图交给了你，希望你帮他解决一些问题。</p>
<p>牛牛给你的地图描述的是一块平地，地图上不仅清楚地标出了起点和终点的坐标，还标有若干个<strong>互不相交</strong>圆形区域，每个区域表示一个圆形的水域。对于不会游泳的牛牛来说，进入水域是根本不可能的。因此，牛牛的行动路线不能从水域中穿过。牛牛想知道这样的路线长度最小可以是多少。</p>
<h3 id="输入格式">输入格式：</h3>
<p>第一行包含四个实数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>S</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>T</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>T</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">S_x,S_y,T_x,T_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>分别表示起点的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>坐标和终点的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>坐标。</p>
<p>第二行包含一个整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，表示水域的个数。</p>
<p>接下来<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>行，每行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>个整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i,y_i,r_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示一片水域的圆心的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>坐标和半径。</p>
<p>保证起点和终点都不在水域的内部或边界上，起点和终点不重合。</p>
<h3 id="输出格式">输出格式：</h3>
<p>输出一行，包含一个实数，四舍五入精确到小数点后<strong>恰好1位</strong>，表示答案。你的输出必须和标准输出<strong>完全一样</strong>才算正确。</p>
<p>测试数据保证四舍五入后的答案和准确答案的差的绝对值不大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">4×10^{-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>。</p>
<p>（如果你不知道什么是浮点误差，这段话可以理解为：对于大多数的算法，你可以正常地使用浮点数类型而不用对它进行特殊的处理）</p>
<h3 id="题目链接httpuojacproblem277">题目链接：http://uoj.ac/problem/277</h3>
<hr>
<h2 id="解题报告">解题报告：</h2>
<p>显然这个是一个圆形障碍最短路的问题；</p>
<p>我们考虑拆点，然后跑最短路算法（<strong>dijkstra</strong>或者<s>SPFA</s>）。</p>
<h4 id="首先我们要考虑怎么判断是否存在两点的合法路径即线段是否与圆相交">首先我们要考虑怎么判断，是否存在两点的合法路径，即线段是否与圆相交。</h4>
<p>第一点，圆心到直线的距离是否小于圆的半径，显然只有距离小于半径才可能会产生影响。（我们可以使用叉积来判断点到直线的距离）</p>
<p>第二点，圆心在直线的投影点是否在线段上；</p>
<p>也许会有疑问为什么投影点在线段上就存在覆盖，不在线段上就不会覆盖吗？（题面给出是互不相交的圆形区域，那么假如投影点不在线段上并且一个圆形对线段存在覆盖的话，必然会覆盖线段的一个端点，显然与题意不符合，后面会写到线段两个端点的来源）</p>
<figure data-type="image" tabindex="1"><img src="https://https://luxin-oi.github.io//post-images/1583222222375.png" alt="" loading="lazy"></figure>
<p>先上图，我们考虑<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>P</mi><mi mathvariant="normal">，</mi><mi>P</mi><mi>Q</mi><mi mathvariant="normal">和</mi><mi>O</mi><mi>D</mi></mrow><annotation encoding="application/x-tex">OP，PQ和OD</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">Q</span><span class="mord cjk_fallback">和</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span>三者长度之间的关系，显然如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span>在直线<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>Q</mi></mrow><annotation encoding="application/x-tex">PQ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">Q</span></span></span></span>上的投影点在线段<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>Q</mi></mrow><annotation encoding="application/x-tex">PQ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">Q</span></span></span></span> 那么必然存在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><msup><mi>P</mi><mn>2</mn></msup><mo>+</mo><mi>O</mi><msup><mi>D</mi><mn>2</mn></msup><mo>&lt;</mo><mi>P</mi><msup><mi>Q</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">OP^2+OD^2&lt;PQ^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.853208em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>并且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><msup><mi>Q</mi><mn>2</mn></msup><mo>+</mo><mi>O</mi><msup><mi>D</mi><mn>2</mn></msup><mo>&lt;</mo><mi>Q</mi><msup><mi>P</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">OQ^2+OD^2&lt;QP^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.853208em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p>
<h4 id="然后我们考虑起点和终点与每个圆形的连线">然后我们考虑起点和终点与每个圆形的连线</h4>
<p>假如要绕过一个圆形障碍的话，必然要从起点或者终点沿着切线走到圆，然后再走一段圆。(显然当一个圆对路径产生影响的时候我们先沿着切线走到圆，然后在走一段圆，再沿着切线走到点是最短的)这时候我们考虑从起点或终点向圆连接切线。</p>
<figure data-type="image" tabindex="2"><img src="https://https://luxin-oi.github.io//post-images/1583222256368.png" alt="" loading="lazy"></figure>
<p>显然</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∠</mi><mi>P</mi><mi>O</mi><mi>K</mi><mn>2</mn><mo>=</mo><mi mathvariant="normal">∠</mi><mi>P</mi><mi>O</mi><mi>K</mi><mn>1</mn><mo>=</mo><mi>arccos</mi><mo>⁡</mo><mo>(</mo><mfrac><mrow><mi>O</mi><mi>K</mi><mn>1</mn><mo>=</mo><mi>R</mi></mrow><mrow><mi>P</mi><mi>O</mi></mrow></mfrac><mo>)</mo></mrow><annotation encoding="application/x-tex">\angle POK2=\angle POK1=\arccos(\frac{OK1=R}{PO})
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mord">∠</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mord">∠</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mop">arccos</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>这样我们就能计算角度了</p>
<p>然后我们建立<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>O</mi><mi>P</mi></mrow><mo stretchy="true">→</mo></mover></mrow><annotation encoding="application/x-tex">\overrightarrow{OP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.20533em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.20533em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span><span class="svg-align" style="top:-3.6833299999999998em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span></span></span></span></span></span></span>方向上的单位向量，旋转正负角度，就能得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>O</mi><mi>K</mi><mn>1</mn></mrow><mo stretchy="true">→</mo></mover></mrow><annotation encoding="application/x-tex">\overrightarrow{OK1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.20533em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.20533em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord">1</span></span></span><span class="svg-align" style="top:-3.6833299999999998em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>O</mi><mi>K</mi><mn>2</mn></mrow><mo stretchy="true">→</mo></mover></mrow><annotation encoding="application/x-tex">\overrightarrow{OK2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.20533em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.20533em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord">2</span></span></span><span class="svg-align" style="top:-3.6833299999999998em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span></span></span></span></span></span></span>方向的单位向量了，最后我们从点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>向他们建边。（当然再计算之前需要判断合法性）</p>
<h4 id="下一步考虑两个圆的连边">下一步考虑两个圆的连边</h4>
<p>与上一步相同，我们可以发现两个圆之间的连线必然是两个圆的内公切线或外公切线。</p>
<h5 id="首先我们考虑两个不相交圆的外公切线">首先我们考虑两个不相交圆的外公切线</h5>
<figure data-type="image" tabindex="3"><img src="https://https://luxin-oi.github.io//post-images/1583222274648.png" alt="" loading="lazy"></figure>
<p>我们需要求的就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∠</mi><mi>α</mi></mrow><annotation encoding="application/x-tex">\angle\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mord">∠</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∠</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">\angle \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∠</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>=</mo><mi>arccos</mi><mo>⁡</mo><mfrac><mrow><mi>r</mi><mn>1</mn><mo>−</mo><mi>r</mi><mn>2</mn></mrow><mi>d</mi></mfrac><mo separator="true">,</mo><mi>β</mi><mo>=</mo><mi>arccos</mi><mo>⁡</mo><mfrac><mrow><mi>r</mi><mn>2</mn><mo>−</mo><mi>r</mi><mn>1</mn></mrow><mi>d</mi></mfrac></mrow><annotation encoding="application/x-tex">\alpha=\arccos\frac{r1-r2}{d},\beta=\arccos\frac{r2-r1}{d}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mop">arccos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mop">arccos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<h5 id="然后我们考虑他们的内公切线">然后我们考虑他们的内公切线</h5>
<figure data-type="image" tabindex="4"><img src="https://https://luxin-oi.github.io//post-images/1583222292908.png" alt="" loading="lazy"></figure>
<p>与上面求的类似</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>=</mo><mi>β</mi><mo>=</mo><mi>arccos</mi><mo>⁡</mo><mfrac><mrow><mi>r</mi><mn>1</mn><mo>+</mo><mi>r</mi><mn>2</mn></mrow><mi>d</mi></mfrac></mrow><annotation encoding="application/x-tex">\alpha=\beta=\arccos\frac{r1+r2}{d}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mop">arccos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>假如合法的情况下，我们建立以上四条连边</p>
<h4 id="之后对每个圆上的拆点连边">之后对每个圆上的拆点连边</h4>
<p>关于拆点，先前计算的点关于圆心的向量，我们可以使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>t</mi><mi>a</mi><mi>n</mi><mn>2</mn><mo>(</mo><mi>y</mi><mo separator="true">,</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">atan2(y,x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>来记录拆点关于圆心的位置（<s>极坐标</s>）。</p>
<figure data-type="image" tabindex="5"><img src="https://https://luxin-oi.github.io//post-images/1583222317070.png" alt="" loading="lazy"></figure>
<p>然后我们只要把圆上每个相邻的拆点连边就好了。</p>
<figure data-type="image" tabindex="6"><img src="https://https://luxin-oi.github.io//post-images/1583222346384.png" alt="" loading="lazy"></figure>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>=</mo><mi>α</mi><mo>∗</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l=\alpha * r
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span></span></p>
<h4 id="最后跑最短路即可">最后跑最短路即可</h4>
<hr>
<h2 id="代码实现">代码实现：</h2>
<pre><code class="language-c++">#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
using namespace std;
#define I inline
#define R register
#define inf 1073742823
#define FOR(i,begin,end) for(R int i=begin;i&lt;=end;++i)
#define ROF(i,begin,end) for(R int i=begin;i&gt;=end;--i)
const int N = 1000+10;
const int M = 1000000+10; 
const double eps=1e-10;
const double pi=acos(-1.0);
#define P point
#define PP const P&amp;
struct point{
    double x,y;
    I P(const double &amp;_x=0,const double &amp;_y=0):x(_x),y(_y){}
    bool operator&lt;(PP a)const{return x&lt;a.x||(x==a.x&amp;&amp;y&lt;a.y);}
    I P operator+(PP a)const{return P(x+a.x,y+a.y);}
    I P operator-(PP a)const{return P(x-a.x,y-a.y);}
    I P operator*(const double a)const{return P(x*a,y*a);}
    I P operator/(const double a)const{return P(x/a,y/a);}
    I P operator*(PP a)const{return P(x*a.x-y*a.y,x*a.y+y*a.x);}
    I double operator|(PP a)const{return x*a.x+y*a.y;}
    I double operator&amp;(PP a)const{return x*a.y-y*a.x;}
    I double len(){return sqrt(x*x+y*y);}
    I double len2(){return x*x+y*y;}
    I P rotate(const double theta)const{return P(x,y)*P(cos(theta),sin(theta));}
};
int n;
typedef P vec;
namespace EDGE{
    int cnt=1,head[M],idt=2;
    struct E{
        int to;double v;int nxt;
        E(const int &amp;_to=0,const double &amp;_v=0,const int &amp;_nxt=0):to(_to),v(_v),nxt(_nxt){}
    }e[1&lt;&lt;22];
    I void add(const int &amp;x,const int &amp;y,const double &amp;v){
        e[++cnt]=E(y,v,head[x]),head[x]=cnt;
        e[++cnt]=E(x,v,head[y]),head[y]=cnt;
    }
}
using namespace EDGE;
struct D{
    int id;double pos;
    I D(const int &amp;_id=0,const double &amp;_pos=0):id(_id),pos(_pos){}
    bool operator&lt;(const D&amp;a)const{return pos&lt;a.pos;}
}v[N&lt;&lt;2];
struct C{
    P o;double r;int tot,id[N&lt;&lt;2];double pos[N&lt;&lt;2];
    I int add(const double t){pos[++tot]=t;return id[tot]=++idt;}
}cir[N],s,t;
P base;
struct T{
    P o;double r;int id;
    I bool operator&lt;(const T&amp;a)const{return (o-base).len2()&lt;(a.o-base).len2();}
}tmp[N];
I int check(PP p,PP q,int b1=0,int b2=0){
    vec v=q-p;
    double  vlen2=v.len2(),
            vlen=sqrt(vlen2),
            dis;
    FOR(i,1,n)
    if(tmp[i].id!=b1&amp;&amp;tmp[i].id!=b2&amp;&amp;
        (dis=abs(v&amp;(tmp[i].o-p))/vlen)&lt;tmp[i].r&amp;&amp;
            (tmp[i].o-p).len2()&lt;dis*dis+vlen2&amp;&amp;(tmp[i].o-q).len2()&lt;dis*dis+vlen2)
                return 0;
    return 1;
}
I void link0(const int &amp;_,const int &amp;ii,C a,C &amp;b){
    vec d=a.o-b.o;
    double t=acos(b.r/d.len());
    d=d/d.len()*b.r;
    P d1=d.rotate(t),d2=d.rotate(-t);
    double len=sqrt((a.o-b.o).len2()-b.r*b.r);
    if(check(a.o,b.o+d1,ii))
        add(_,b.add(atan2(d1.y,d1.x)),len);
    if(check(a.o,b.o+d2,ii))
        add(_,b.add(atan2(d2.y,d2.x)),len);
}
I void link1(const int &amp;ja,const int &amp;jb,C &amp;a,C &amp;b){
    vec d=a.o-b.o;
    if(abs(d.len()-a.r-b.r)&lt;eps)
        add(a.add(atan2(-d.y,-d.x)),b.add(atan2(d.y,d.x)),0);
    else{
        double t=acos((a.r+b.r)/d.len()),l=sqrt(d.len2()-(a.r+b.r)*(a.r+b.r));
        d=d/d.len();
        vec d1=d.rotate(t)*b.r,d2=d.rotate(-t)*b.r;
        d=d*(-1);
        vec d3=d.rotate(t)*a.r,d4=d.rotate(-t)*a.r;
        if(check(a.o+d3,b.o+d1,ja,jb))
            add(a.add(atan2(d3.y,d3.x)),b.add(atan2(d1.y,d1.x)),l);
        if(check(a.o+d4,b.o+d2,ja,jb))
            add(a.add(atan2(d4.y,d4.x)),b.add(atan2(d2.y,d2.x)),l);
    }
    d=a.o-b.o;
    double t=acos((b.r-a.r)/d.len()),l=sqrt(d.len2()-(b.r-a.r)*(b.r-a.r));
    d=d/d.len();
    vec d1=d.rotate(t),d2=d.rotate(-t);
    if(check(a.o+d1*a.r,b.o+d1*b.r,ja,jb))
		add(a.add(atan2(d1.y,d1.x)),b.add(atan2(d1.y,d1.x)),l);
	if(check(a.o+d2*a.r,b.o+d2*b.r,ja,jb))
		add(a.add(atan2(d2.y,d2.x)),b.add(atan2(d2.y,d2.x)),l);
}
I void link2(C&amp;a){
    FOR(i,1,a.tot)v[i]=D(a.id[i],a.pos[i]);
    sort(v+1,v+1+a.tot);
    v[a.tot+1]=v[1];v[a.tot+1].pos+=2*pi;
    FOR(i,1,a.tot)add(v[i].id,v[i+1].id,(v[i+1].pos-v[i].pos)*a.r);
}
int in[M];double d[M];
struct Q{
    int key;double value;
    I Q(const int &amp;_key=0,const double &amp;_value=0):key(_key),value(_value){}
    I bool operator&lt;(const Q&amp;a)const{return value&gt;a.value;}
};
priority_queue&lt;Q&gt;q;
double dijkstra(){
    FOR(i,2,idt)d[i]=1e10;
    for(q.push(Q(1,d[1]=0));!q.empty();){
        Q tmp=q.top();q.pop();
        if(in[tmp.key])continue;
        in[tmp.key]=1;
        for(int i=head[tmp.key];i;i=e[i].nxt)
        if(d[e[i].to]&gt;d[tmp.key]+e[i].v)
            q.push(Q(e[i].to,d[e[i].to]=d[tmp.key]+e[i].v));
    }
    return d[2];
}
signed main(){
    scanf(&quot;%lf%lf%lf%lf%d&quot;,&amp;s.o.x,&amp;s.o.y,&amp;t.o.x,&amp;t.o.y,&amp;n);
    s.r=t.r=0;
    FOR(i,1,n)
        scanf(&quot;%lf%lf%lf&quot;,&amp;cir[i].o.x,&amp;cir[i].o.y,&amp;cir[i].r),
        tmp[i].o=cir[i].o,tmp[i].r=cir[i].r,tmp[i].id=i;
    if(check(s.o,t.o))add(1,2,(s.o-t.o).len());
    FOR(i,1,n)
        link0(1,i,s,cir[i]),link0(2,i,t,cir[i]);
    FOR(i,1,n){
        base=cir[i].o; 
        sort(tmp+1,tmp+1+n);
        ROF(j,n,i+1){
            if(cir[i].r&lt;=cir[j].r)link1(i,j,cir[i],cir[j]);
			else link1(j,i,cir[j],cir[i]);
        }
    }
    FOR(i,1,n)link2(cir[i]);
    printf(&quot;%.1lf\n&quot;,dijkstra());
    return 0;
}

</code></pre>
<p><s>显然这是一个披着计算几何皮的码力题</s></p>
<p>关于代码冗余：</p>
<pre><code>开float即可，double没必要，题目要求的精度没有那么高；
eps设置的毫无意义；
比较半径大小好像也没有必要；(sort&amp;link1)
</code></pre>
<hr>
<h2 id="后记">后记：</h2>
<p>本文写于北京时间2020年2月29日21时59分，也是我的第一篇计算几何的笔记（此时并不会维护凸包）。</p>
<p>代码参考了uoj上的提交记录（自己码力不够），绘图参考了罗哲正的课件。</p>
<p>祝自己，也祝大家再OI的路上越走越走吧<sub>(￣▽￣)</sub>*</p>
<p>​																																										——luxin</p>
]]></content>
    </entry>
</feed>